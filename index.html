<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ib-lol</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#0a0a1a; color:#e0e0e0; font-family:'Courier New',monospace; font-size:14px; overflow-x:hidden; }
#game { max-width:960px; margin:0 auto; padding:16px; position:relative; }
h1 { text-align:center; color:#f0c040; margin-bottom:2px; font-size:22px; }
.subtitle { text-align:center; color:#888; margin-bottom:12px; font-size:11px; }

/* Map */
#map { display:flex; justify-content:center; margin-bottom:12px; }
#map table { border-collapse:collapse; }
#map td {
  width:48px; height:48px; border:1px solid #1a1a1a; text-align:center; vertical-align:middle;
  font-size:16px; background:#0d0d15; cursor:default; transition:background 0.15s; position:relative;
}
#map td.wall { background:#111; }
#map td.walkable { background:#0d0d15; }
#map td.highlight { background:#333300 !important; border-color:#555500; cursor:pointer; }
#map td.target-mode { background:#2a0a0a !important; border-color:#552200; cursor:crosshair; }
#map td.reveal-flash { animation:revealPulse 1s ease-out; }
#map td .unit { display:block; line-height:1.1; font-size:18px; }
#map td .sub { font-size:8px; display:block; color:#aaa; }
#map td .minion-marker { font-size:14px; }
#map td .ghost { opacity:0.35; }

/* Stats */
.stats-row { display:flex; gap:8px; margin-bottom:10px; }
.stat-panel { flex:1; background:#111; border:1px solid #333; padding:10px; border-radius:4px; }
.stat-panel.player { border-color:#4488ff; }
.stat-panel.enemy { border-color:#ff4444; }
.stat-panel h3 { margin-bottom:6px; font-size:13px; }
.bar-container { background:#222; border-radius:3px; height:18px; position:relative; margin-bottom:4px; overflow:hidden; }
.bar-fill { height:100%; border-radius:3px; transition:width 0.3s; }
.bar-hp .bar-fill { background:linear-gradient(90deg,#22aa22,#44ff44); }
.bar-mp .bar-fill { background:linear-gradient(90deg,#2244aa,#4488ff); }
.bar-label { position:absolute; top:0; left:0; right:0; height:100%; display:flex; align-items:center; justify-content:center; font-size:10px; color:#fff; text-shadow:1px 1px 2px #000; }
.passive-bar { font-size:11px; margin-top:3px; }
.passive-bar .stack { display:inline-block; width:12px; height:12px; border:1px solid #666; border-radius:2px; margin-right:2px; }
.passive-bar .stack.filled { background:#ff6600; border-color:#ff8800; }
.passive-bar .stack.ready { background:#ff00ff; border-color:#ff44ff; animation:pulse 0.5s infinite alternate; }
.skill-row { display:flex; gap:4px; margin-top:4px; }
.skill-badge { font-size:10px; padding:2px 5px; border-radius:3px; background:#1a1a1a; border:1px solid #444; }
.skill-badge.on-cd { opacity:0.35; }
.skill-badge.ready { border-color:#44ff44; color:#44ff44; }
.skill-lvlup { display:flex; gap:4px; margin-top:4px; }
.skill-lvlup button { font-size:10px; padding:2px 8px; background:#1a1a00; border:1px solid #f0c040; color:#f0c040; border-radius:3px; cursor:pointer; font-family:inherit; animation:pulse 0.8s infinite alternate; }
.skill-lvlup button:hover { background:#333300; }
.enemy-unknown { color:#666; font-style:italic; font-size:11px; }

/* Turn phase */
#phase-bar { background:#111; border:1px solid #f0c040; padding:10px; margin-bottom:10px; border-radius:4px; text-align:center; }
#phase-bar .phase-title { color:#f0c040; font-size:13px; font-weight:bold; margin-bottom:6px; }
#phase-bar .ai-action { color:#ff6644; font-size:12px; margin-bottom:6px; }
#phase-bar .player-action { color:#88aaff; font-size:12px; margin-bottom:6px; }

/* Actions */
#actions { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:10px; justify-content:center; }
#actions button { background:#222; color:#e0e0e0; border:1px solid #555; padding:7px 14px; cursor:pointer; border-radius:4px; font-family:inherit; font-size:12px; transition:all 0.15s; }
#actions button:hover:not(:disabled) { background:#333; border-color:#aaa; }
#actions button:disabled { opacity:0.3; cursor:not-allowed; }
#actions button.move { border-color:#44aa44; }
#actions button.attack { border-color:#ff6644; }
#actions button.skill-q { border-color:#ff8800; }
#actions button.skill-w { border-color:#ff4444; }
#actions button.skill-e { border-color:#44aaff; }
#actions button.skill-r { border-color:#ff00ff; background:#1a0020; }
#actions button.confirm { border-color:#f0c040; background:#2a2a00; color:#f0c040; font-weight:bold; }
#actions button.confirm:hover { background:#444400; }
#actions button.cancel { border-color:#ff4444; }

/* Log */
#log { background:#0a0a0a; border:1px solid #333; padding:8px; height:180px; overflow-y:auto; margin-bottom:10px; border-radius:4px; font-size:11px; line-height:1.5; }
.log-turn { color:#f0c040; font-weight:bold; }
.log-dmg { color:#ff6644; }
.log-heal { color:#44ff44; }
.log-info { color:#88aaff; }
.log-kill { color:#ff44ff; }
.log-ult { color:#ff00ff; font-weight:bold; }
.log-reveal { color:#ffcc00; font-weight:bold; }
.log-miss { color:#666; }

/* Effects */
#ult-overlay { position:fixed; top:0; left:0; width:100vw; height:100vh; pointer-events:none; z-index:100; opacity:0; transition:opacity 0.15s; }
#ult-overlay.flash { opacity:1; }
@keyframes shake { 0%,100%{transform:translate(0,0)}10%{transform:translate(-6px,3px)}30%{transform:translate(4px,-4px)}50%{transform:translate(-3px,5px)}70%{transform:translate(5px,-2px)}90%{transform:translate(-4px,2px)} }
.screen-shake { animation:shake 0.4s ease; }
@keyframes pulse { from{opacity:0.6}to{opacity:1} }
@keyframes revealPulse { 0%{box-shadow:0 0 20px #ffcc00}100%{box-shadow:none} }

/* Game over */
#game-over-overlay { display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:200; justify-content:center; align-items:center; flex-direction:column; }
#game-over-overlay.show { display:flex; }
#game-over-overlay.victory { background:radial-gradient(ellipse at center,rgba(255,200,0,0.3) 0%,rgba(0,0,0,0.9) 70%); }
#game-over-overlay.defeat { background:radial-gradient(ellipse at center,rgba(255,0,0,0.2) 0%,rgba(0,0,0,0.95) 70%); }
#game-over-text { font-size:56px; font-weight:bold; letter-spacing:8px; margin-bottom:16px; animation:resultAppear 0.8s ease-out; }
#game-over-overlay.victory #game-over-text { color:#f0c040; text-shadow:0 0 30px #f0c040,0 0 60px #ff8800; }
#game-over-overlay.defeat #game-over-text { color:#ff2222; text-shadow:0 0 30px #ff0000,0 0 60px #880000; }
#game-over-sub { font-size:14px; color:#aaa; margin-bottom:24px; animation:resultAppear 1s ease-out; }
#game-over-overlay button { background:none; border:2px solid #888; color:#e0e0e0; padding:10px 36px; font-size:16px; cursor:pointer; border-radius:4px; font-family:inherit; animation:resultAppear 1.2s ease-out; }
#game-over-overlay button:hover { border-color:#f0c040; color:#f0c040; }
@keyframes resultAppear { 0%{opacity:0;transform:scale(0.5) translateY(20px)}100%{opacity:1;transform:scale(1) translateY(0)} }
.particle { position:fixed; pointer-events:none; z-index:90; border-radius:50%; animation:particleFly 1s ease-out forwards; }
@keyframes particleFly { 0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0) translateY(-100px)} }
</style>
</head>
<body>
<div id="game">
  <h1>âš”ï¸ ib-lol âš”ï¸</h1>
  <div class="subtitle">í„´ì œ 1v1 â€” ì•ˆê°œ ì†ì˜ ë¼ì¸ì „</div>
  <div id="map"></div>
  <div class="stats-row">
    <div class="stat-panel player" id="player-stats"></div>
    <div class="stat-panel enemy" id="enemy-stats"></div>
  </div>
  <div id="phase-bar"></div>
  <div id="actions"></div>
  <div id="log"></div>
</div>
<div id="ult-overlay"></div>
<div id="game-over-overlay">
  <div id="game-over-text"></div>
  <div id="game-over-sub"></div>
  <button onclick="restartGame()">ë‹¤ì‹œ í•˜ê¸°</button>
</div>

<script>
// ============ CONFIG ============
const COLS=15, ROWS=7;
const REVEAL_INTERVAL=5;
const MINION_RESPAWN_INTERVAL=10;

// Map: 0=wall, 1=walkable
const MAP=[];
for(let y=0;y<ROWS;y++){MAP[y]=[];for(let x=0;x<COLS;x++){MAP[y][x]=(x===0||x===COLS-1||y===0||y===ROWS-1)?0:1;}}

// Fixed minion positions (symmetrical)
const MINION_POSITIONS=[
  {x:5,y:2},{x:3,y:3},{x:5,y:4},{x:3,y:5},
  {x:7,y:1},{x:7,y:3},{x:7,y:5},
  {x:9,y:2},{x:11,y:3},{x:9,y:4},{x:11,y:1},
];
// Buff monsters (ì¢Œìƒë‹¨, ìš°í•˜ë‹¨)
const BUFF_POSITIONS=[
  {x:3,y:1,type:'red'},    // Red buff - ì¢Œìƒë‹¨
  {x:11,y:5,type:'blue'},  // Blue buff - ìš°í•˜ë‹¨
];
const BUFF_RESPAWN=15; // respawn every 15 turns
const BUFF_DURATION=10; // buff lasts 10 turns
const BUFF_XP=200, BUFF_GOLD=50;

const ANNIE={
  name:'Annie',hp:560,mp:418,ad:50,ap:0,armor:19,mr:30,
  hpPerLvl:88,mpPerLvl:25,adPerLvl:2.7,armorPerLvl:4,mrPerLvl:1.3,
  skills:{
    passive:{name:'íŒŒì´ë¡œë§¤ë‹ˆì•„',stacksNeeded:4},
    q:{name:'ë¶•ê´´',key:'Q',baseDmg:[80,115,150,185,220],manaCost:60,cooldown:0,range:3,type:'target'},
    w:{name:'ì†Œê°',key:'W',baseDmg:[70,115,160,205,250],manaCost:70,cooldown:1,range:2,type:'aoe',aoeRadius:1},
    e:{name:'ë³´í˜¸ë§‰',key:'E',baseShield:[40,65,90,115,140],shieldApRatio:0.4,manaCost:40,cooldown:3,type:'self'},
    r:{name:'í‹°ë²„',key:'R',baseDmg:[150,275,400],manaCost:100,cooldown:8,range:3,type:'aoe',aoeRadius:1,summon:true}
  }
};

const MAX_LEVEL=18;
const XP_PER_LEVEL=[0,180,240,300,360,420,480,540,600,660,720,780,840,900,960,1020,1080,1140];
const MINION_XP=120, MINION_GOLD=25, CHAMPION_KILL_XP=300;
const SKILL_MAX={q:5,w:5,e:5,r:3};
const R_UNLOCK=[6,11,16];
const AI_SKILL_ORDER=['q','w','q','e','q','r','w','w','q','w','e','r','q','w','e','r','e','e'];

// ============ UTIL ============
function dist(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}
function isWalkable(x,y){return x>=0&&x<COLS&&y>=0&&y<ROWS&&MAP[y][x]===1;}

// ============ SKILL HELPERS ============
function getSkillDmg(key,lvl){const s=ANNIE.skills[key];if(!s.baseDmg||lvl<=0)return 0;return s.baseDmg[Math.min(lvl-1,s.baseDmg.length-1)]||0;}
function getShield(lvl){const s=ANNIE.skills.e;if(lvl<=0)return 0;return s.baseShield[Math.min(lvl-1,s.baseShield.length-1)]||0;}
function canLvlSkill(c,k){if(c.skillPoints<=0||c.skillLevels[k]>=SKILL_MAX[k])return false;if(k==='r'){const rl=c.skillLevels.r;return rl<3&&c.level>=R_UNLOCK[rl];}return true;}
function lvlSkill(c,k){if(!canLvlSkill(c,k))return;c.skillLevels[k]++;c.skillPoints--;log(`â¬†ï¸ ${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ${ANNIE.skills[k].key} ìŠ¤í‚¬ Lv.${c.skillLevels[k]}`,'log-heal');render();}
function aiAutoLvl(c){while(c.skillPoints>0){const t=c.skillLevels.q+c.skillLevels.w+c.skillLevels.e+c.skillLevels.r;const n=AI_SKILL_ORDER[t];if(n&&canLvlSkill(c,n)){c.skillLevels[n]++;c.skillPoints--;}else break;}}

// ============ STATE ============
let state;

function createChamp(team,x,y){
  const c={type:'champion',team,name:ANNIE.name,x,y,
    baseHp:ANNIE.hp,baseMp:ANNIE.mp,baseAd:ANNIE.ad,
    maxHp:ANNIE.hp,hp:ANNIE.hp,maxMp:ANNIE.mp,mp:ANNIE.mp,
    ad:ANNIE.ad,ap:ANNIE.ap,armor:ANNIE.armor,mr:ANNIE.mr,
    level:1,xp:0,skillPoints:1,skillLevels:{q:0,w:0,e:0,r:0},
    passiveStacks:0,shield:0,cooldowns:{q:0,w:0,e:0,r:0},
    tibbers:null,gold:0,alive:true,stunned:false,redBuff:0,blueBuff:0};
  recalc(c);return c;
}
function recalc(c){
  const l=c.level;
  c.maxHp=Math.floor(c.baseHp+ANNIE.hpPerLvl*(l-1));
  c.maxMp=Math.floor(c.baseMp+ANNIE.mpPerLvl*(l-1));
  c.ad=Math.floor(c.baseAd+ANNIE.adPerLvl*(l-1));
  c.armor=Math.floor(ANNIE.armor+ANNIE.armorPerLvl*(l-1));
  c.mr=Math.floor(ANNIE.mr+ANNIE.mrPerLvl*(l-1));
}
function grantXP(c,amt){
  if(c.level>=MAX_LEVEL)return;
  c.xp+=amt;
  while(c.level<MAX_LEVEL&&c.xp>=XP_PER_LEVEL[c.level]){
    c.xp-=XP_PER_LEVEL[c.level];c.level++;c.skillPoints++;
    const oh=c.maxHp,om=c.maxMp;recalc(c);
    c.hp+=c.maxHp-oh;c.mp+=c.maxMp-om;
    const cl=c.team==='blue'?'ğŸ”µ':'ğŸ”´';
    log(`â¬†ï¸ ${cl} ë ˆë²¨ ì—…! Lv.${c.level}`,'log-heal');
    if(c.team==='red')aiAutoLvl(c);
  }
}
function calcDmg(raw,type,tgt){const d=type==='magic'?(tgt.mr||0):(tgt.armor||0);return Math.max(1,Math.floor(raw*(100/(100+d))));}
function applyDmg(tgt,amt){
  if(tgt.shield>0){if(tgt.shield>=amt){tgt.shield-=amt;return 0;}amt-=tgt.shield;tgt.shield=0;}
  tgt.hp=Math.max(0,tgt.hp-amt);if(tgt.hp<=0)tgt.alive=false;return amt;
}

function initGame(){
  state={
    turn:1,
    player:createChamp('blue',2,3),
    enemy:createChamp('red',12,3),
    minions:MINION_POSITIONS.map((p,i)=>({type:'minion',x:p.x,y:p.y,alive:true,id:i})),
    buffs:BUFF_POSITIONS.map(b=>({type:'buff',buffType:b.type,x:b.x,y:b.y,alive:true,hp:3,maxHp:3,armor:10,mr:10,lastKillTurn:0})),
    tibbersList:[],
    logs:[],
    // Phase: 'plan' = choosing action, 'target' = choosing target cell
    phase:'plan',
    playerAction:null, // {type:'move'|'attack'|'skill',dir?,target?,key?}
    aiAction:null,
    targetMode:null, // null or {type,key,range}
    lastRevealTurn:0,
    lastEnemyReveal:null, // {x,y,hp,maxHp,mp,maxMp,level} shown during reveal
    gameOver:false
  };
  aiAutoLvl(state.enemy);
  spawnMinions();
  planPhase();
  log(`â”â”â” í„´ ${state.turn} â”â”â”`,'log-turn');
  log('ğŸ“ ì  ìœ„ì¹˜ëŠ” 5í„´ë§ˆë‹¤ ê³µê°œë©ë‹ˆë‹¤','log-info');
  render();
}
function restartGame(){
  document.getElementById('game-over-overlay').classList.remove('show','victory','defeat');
  initGame();
}
function log(msg,cls=''){state.logs.push({msg,cls});}

// ============ MINIONS ============
function spawnMinions(){
  state.minions.forEach((m,i)=>{
    if(!m.alive){m.alive=true;m.x=MINION_POSITIONS[i].x;m.y=MINION_POSITIONS[i].y;}
  });
}

// ============ TURN PHASES ============
function planPhase(){
  state.phase='plan';
  state.playerAction=null;
  state.targetMode=null;
  state.aiLocked=false;
  state.playerLocked=false;
  // AI decides first
  state.aiAction=aiDecideAction();
  render();
}

// After player confirms, AI gets a chance to react
function aiReact(){
  // AI sees player's action and may change its mind
  const old=state.aiAction;
  const newAction=aiDecideReaction(state.playerAction);
  if(newAction&&newAction.desc!==old.desc){
    state.aiAction=newAction;
    log(`ğŸ”´ AIê°€ í–‰ë™ì„ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!`,'log-info');
    // Player gets one more chance
    state.playerLocked=false;
    state.aiLocked=true;
    render();
    return false; // not ready to execute
  }
  state.aiLocked=true;
  return true; // ready
}

function aiDecideReaction(playerAction){
  const ai=state.enemy,p=state.player;
  if(!ai.alive||ai.stunned)return null;

  // AI only knows player position if revealed recently
  const knowsPlayer=state.lastRevealTurn>0&&(state.turn-state.lastRevealTurn)<=2;

  // If player is attacking a cell near AI, try to dodge
  if(playerAction&&(playerAction.type==='attack'||playerAction.type==='skill')&&playerAction.target){
    const t=playerAction.target;
    const d=dist({x:ai.x,y:ai.y},t);
    const aoe=(playerAction.type==='skill'&&ANNIE.skills[playerAction.key]?.aoeRadius)||0;
    if(d<=aoe){
      const dirs=[[0,-1],[0,1],[-1,0],[1,0]];
      for(const[dx,dy]of dirs){
        const nx=ai.x+dx,ny=ai.y+dy;
        if(isWalkable(nx,ny)&&dist({x:nx,y:ny},t)>aoe){
          return{type:'move',dir:{x:dx,y:dy},desc:'ğŸš¶ ì´ë™'};
        }
      }
    }
  }

  // AI can NOT see player's move destination â€” no reaction to movement
  return null;
}

function aiDecideAction(){
  const ai=state.enemy,p=state.player;
  if(!ai.alive)return{type:'wait',desc:'ëŒ€ê¸°'};
  if(ai.stunned)return{type:'wait',desc:'âš¡ ìŠ¤í„´ ìƒíƒœ'};

  // Try to find and kill nearby minion for gold/xp
  const nearMinion=state.minions.find(m=>m.alive&&dist({x:ai.x,y:ai.y},{x:m.x,y:m.y})<=1);
  if(nearMinion)return{type:'attack',target:{x:nearMinion.x,y:nearMinion.y},desc:`âš”ï¸ í‰íƒ€ â†’ (${nearMinion.x},${nearMinion.y})`};

  // AI only knows player position if revealed recently (within 2 turns)
  const knowsPlayer=state.lastRevealTurn>0&&(state.turn-state.lastRevealTurn)<=2;
  // AI's guess of player position â€” last known or random
  let guessX=p.x, guessY=p.y; // only accurate if knowsPlayer
  if(!knowsPlayer&&state.lastEnemyReveal){
    // AI remembers player's last revealed position but it's stale â€” guess nearby
    // Not accurate, just a rough area guess
    guessX=state.lastPlayerRevealX||(COLS>>1);
    guessY=state.lastPlayerRevealY||(ROWS>>1);
  }

  if(knowsPlayer){
    if(ai.skillLevels.r>0&&ai.cooldowns.r===0&&ai.mp>=100&&dist({x:ai.x,y:ai.y},{x:p.x,y:p.y})<=3){
      return{type:'skill',key:'r',target:{x:p.x,y:p.y},desc:`ğŸ”¥ R í‹°ë²„ â†’ (${p.x},${p.y})`};
    }
    if(ai.skillLevels.q>0&&ai.cooldowns.q===0&&ai.mp>=60&&dist({x:ai.x,y:ai.y},{x:p.x,y:p.y})<=3){
      return{type:'skill',key:'q',target:{x:p.x,y:p.y},desc:`Q ë¶•ê´´ â†’ (${p.x},${p.y})`};
    }
    if(ai.skillLevels.w>0&&ai.cooldowns.w===0&&ai.mp>=70&&dist({x:ai.x,y:ai.y},{x:p.x,y:p.y})<=2){
      return{type:'skill',key:'w',target:{x:p.x,y:p.y},desc:`W ì†Œê° â†’ (${p.x},${p.y})`};
    }
  }

  if(ai.skillLevels.e>0&&ai.cooldowns.e===0&&ai.shield===0&&ai.mp>=40){
    return{type:'skill',key:'e',desc:'E ë³´í˜¸ë§‰'};
  }

  // Move toward nearest minion or wander
  const aliveMinions=state.minions.filter(m=>m.alive);
  let bestMinion=null,bestDist=999;
  for(const m of aliveMinions){const d=dist({x:ai.x,y:ai.y},{x:m.x,y:m.y});if(d<bestDist){bestDist=d;bestMinion=m;}}

  if(bestMinion){
    const dx=Math.sign(bestMinion.x-ai.x),dy=Math.sign(bestMinion.y-ai.y);
    if(dx!==0&&isWalkable(ai.x+dx,ai.y))return{type:'move',dir:{x:dx,y:0},desc:`ğŸš¶ ì´ë™`};
    if(dy!==0&&isWalkable(ai.x,ai.y+dy))return{type:'move',dir:{x:0,y:dy},desc:`ğŸš¶ ì´ë™`};
  }

  return{type:'wait',desc:'ëŒ€ê¸°'};
}

// ============ PLAYER ACTIONS ============
function setPlayerMove(){
  state.phase='target';
  state.targetMode={type:'move'};
  render();
}
function setPlayerAttack(){
  state.phase='target';
  state.targetMode={type:'attack',range:2};
  render();
}
function setPlayerSkill(key){
  const p=state.player,s=ANNIE.skills[key];
  if(p.skillLevels[key]<=0||p.cooldowns[key]>0||p.mp<s.manaCost)return;
  if(s.type==='self'){
    state.playerAction={type:'skill',key,desc:`E ë³´í˜¸ë§‰`};
    state.phase='plan';
    render();return;
  }
  state.phase='target';
  state.targetMode={type:'skill',key,range:s.range};
  render();
}
function selectCell(x,y){
  if(!state.targetMode)return;
  const tm=state.targetMode;
  const p=state.player;

  if(tm.type==='move'){
    const dx=x-p.x,dy=y-p.y;
    if(Math.abs(dx)+Math.abs(dy)!==1)return;
    if(!isWalkable(x,y))return;
    state.playerAction={type:'move',dir:{x:dx,y:dy},dest:{x,y},desc:`ğŸš¶ ì´ë™`};
  } else if(tm.type==='attack'){
    if(dist({x:p.x,y:p.y},{x,y})>tm.range)return;
    state.playerAction={type:'attack',target:{x,y},desc:`âš”ï¸ í‰íƒ€ â†’ (${x},${y})`};
  } else if(tm.type==='skill'){
    const s=ANNIE.skills[tm.key];
    if(dist({x:p.x,y:p.y},{x,y})>s.range)return;
    state.playerAction={type:'skill',key:tm.key,target:{x,y},desc:`${s.key} ${s.name} â†’ (${x},${y})`};
  }
  state.phase='plan';
  state.targetMode=null;
  render();
}
function cancelTarget(){
  state.phase='plan';
  state.targetMode=null;
  render();
}

function confirmActions(){
  if(!state.playerAction){log('âš ï¸ í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš”','log-info');render();return;}

  if(!state.aiLocked){
    // First confirm: AI reacts
    state.playerLocked=true;
    const ready=aiReact();
    if(!ready)return; // AI changed, player can adjust
  }

  // Both locked or AI didn't change
  executeTurn();
}

function finalConfirm(){
  // Player accepts after AI reaction
  state.playerLocked=true;
  state.aiLocked=true;
  executeTurn();
}

// ============ EXECUTE TURN ============
function executeTurn(){
  const p=state.player,e=state.enemy;
  const pa=state.playerAction,aa=state.aiAction;

  // Log actions (move hides coordinates for both sides)
  log(`ğŸ”µ ${pa.desc}`,'log-info');
  log(`ğŸ”´ ${aa.desc}`,'log-info');

  // Execute both simultaneously
  executeAction(p,pa);
  executeAction(e,aa);

  if(checkGameOver()){render();return;}

  // Cooldown tick
  for(let k of['q','w','e','r']){if(p.cooldowns[k]>0)p.cooldowns[k]--;if(e.cooldowns[k]>0)e.cooldowns[k]--;}
  p.stunned=false;e.stunned=false;
  p.mp=Math.min(p.maxMp,p.mp+(p.blueBuff>0?20:10));
  e.mp=Math.min(e.maxMp,e.mp+(e.blueBuff>0?20:10));

  // Minion respawn
  if(state.turn%MINION_RESPAWN_INTERVAL===0){
    spawnMinions();
    log('ğŸ”„ ë¯¸ë‹ˆì–¸ ë¦¬ì  !','log-info');
  }

  // Buff respawn
  state.buffs.forEach(b=>{
    if(!b.alive&&b.lastKillTurn>0&&(state.turn-b.lastKillTurn)>=BUFF_RESPAWN){
      b.alive=true;b.hp=b.maxHp;
      log(`ğŸ’ ${b.buffType==='red'?'ğŸ”´ ë ˆë“œ':'ğŸ”µ ë¸”ë£¨'} ë²„í”„ ëª¬ìŠ¤í„° ë¦¬ì  !`,'log-info');
    }
  });

  // Tick buff durations
  [state.player,state.enemy].forEach(c=>{
    if(c.redBuff&&c.redBuff>0){c.redBuff--;if(c.redBuff===0)log(`${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ë ˆë“œ ë²„í”„ ë§Œë£Œ`,'log-info');}
    if(c.blueBuff&&c.blueBuff>0){c.blueBuff--;if(c.blueBuff===0)log(`${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ë¸”ë£¨ ë²„í”„ ë§Œë£Œ`,'log-info');}
  });

  // Reveal check
  if(state.turn%REVEAL_INTERVAL===0){
    state.lastRevealTurn=state.turn;
    state.lastEnemyReveal={x:e.x,y:e.y,hp:e.hp,maxHp:e.maxHp,mp:e.mp,maxMp:e.maxMp,level:e.level};
    // AI also learns player position on reveal
    state.lastPlayerRevealX=p.x;
    state.lastPlayerRevealY=p.y;
    log(`ğŸ‘ï¸ ì  ìœ„ì¹˜ ê³µê°œ! (${e.x},${e.y}) HP:${e.hp}/${e.maxHp} MP:${e.mp}/${e.maxMp} Lv.${e.level}`,'log-reveal');
  }

  state.turn++;
  log(`â”â”â” í„´ ${state.turn} â”â”â”`,'log-turn');

  // Tibbers AI
  tibbersAI();

  cleanDead();
  if(checkGameOver()){render();return;}
  planPhase();
}

function executeAction(champ,action){
  if(!champ.alive||!action)return;
  if(champ.stunned)return;

  if(action.type==='move'){
    const nx=champ.x+action.dir.x,ny=champ.y+action.dir.y;
    if(isWalkable(nx,ny)){champ.x=nx;champ.y=ny;}
  }
  else if(action.type==='attack'){
    const tx=action.target.x,ty=action.target.y;
    if(dist({x:champ.x,y:champ.y},{x:tx,y:ty})>2)return;

    // Check minion at target
    const minion=state.minions.find(m=>m.alive&&m.x===tx&&m.y===ty);
    if(minion){
      minion.alive=false;
      grantXP(champ,MINION_XP);champ.gold+=MINION_GOLD;
      const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      log(`${cl} ë¯¸ë‹ˆì–¸ ì²˜ì¹˜ (${tx},${ty}) +${MINION_GOLD}G +${MINION_XP}XP`,'log-kill');
    }

    // Check enemy champion at target
    const enemy=champ.team==='blue'?state.enemy:state.player;
    if(enemy.alive&&enemy.x===tx&&enemy.y===ty){
      const atkAd=champ.ad+(champ.redBuff>0?15:0);
      const dmg=calcDmg(atkAd,'physical',enemy);
      applyDmg(enemy,dmg);
      const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´',tl=enemy.team==='blue'?'ğŸ”µ':'ğŸ”´';
      let dmgLog=`${cl} í‰íƒ€ ì ì¤‘! â†’ ${tl} ${dmg} í”¼í•´`;
      if(champ.redBuff>0){const burn=Math.max(1,Math.floor(dmg*0.15));applyDmg(enemy,burn);dmgLog+=` +ğŸ”¥${burn}`;}
      log(dmgLog,'log-dmg');
      if(!enemy.alive){champ.gold+=300;grantXP(champ,CHAMPION_KILL_XP);log(`${cl} ì±”í”¼ì–¸ ì²˜ì¹˜!`,'log-kill');}
    }
    else if(!minion){
      const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      log(`${cl} í‰íƒ€ ë¹—ë‚˜ê° (${tx},${ty})`,'log-miss');
    }

    // Check buff monster at target
    const buff=state.buffs.find(b=>b.alive&&b.x===tx&&b.y===ty);
    if(buff){
      buff.hp--;
      const cl2=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      if(buff.hp<=0){
        buff.alive=false;buff.lastKillTurn=state.turn;
        if(buff.buffType==='red'){champ.redBuff=BUFF_DURATION;log(`${cl2} ğŸ”´ ë ˆë“œ ë²„í”„ íšë“! (AD+15, í‰íƒ€ í™”ìƒ)`,`log-kill`);}
        else{champ.blueBuff=BUFF_DURATION;log(`${cl2} ğŸ”µ ë¸”ë£¨ ë²„í”„ íšë“! (ë§ˆë‚˜ íšŒë³µ 2ë°°)`,`log-kill`);}
        grantXP(champ,BUFF_XP);champ.gold+=BUFF_GOLD;
        log(`${cl2} +${BUFF_XP}XP +${BUFF_GOLD}G`,'log-kill');
      } else {
        log(`${cl2} ë²„í”„ ëª¬ìŠ¤í„° ê³µê²© (${buff.hp}/${buff.maxHp})`,'log-dmg');
      }
    }

    // Check tibbers at target
    const tib=state.tibbersList.find(t=>t.alive&&t.x===tx&&t.y===ty&&t.team!==champ.team);
    if(tib){const dmg=calcDmg(champ.ad,'physical',tib);applyDmg(tib,dmg);}
  }
  else if(action.type==='skill'){
    const key=action.key;
    execSkill(champ,key,action.target);
  }
}

function execSkill(caster,key,target){
  const skill=ANNIE.skills[key];
  if(caster.cooldowns[key]>0||caster.mp<skill.manaCost)return;
  const sLvl=caster.skillLevels[key];if(sLvl<=0)return;

  caster.mp-=skill.manaCost;
  caster.cooldowns[key]=skill.cooldown;
  caster.passiveStacks++;
  let willStun=false;
  if(caster.passiveStacks>=ANNIE.skills.passive.stacksNeeded){willStun=true;caster.passiveStacks=0;}
  const cl=caster.team==='blue'?'ğŸ”µ':'ğŸ”´';

  if(key==='e'){
    const s=Math.floor(getShield(sLvl)+skill.shieldApRatio*caster.ap);
    caster.shield+=s;
    log(`${cl} E ë³´í˜¸ë§‰ +${s}`,'log-info');
    return;
  }
  if(!target)return;
  if(dist({x:caster.x,y:caster.y},target)>skill.range)return;

  const raw=getSkillDmg(key,sLvl)+caster.ap;
  const enemy=caster.team==='blue'?state.enemy:state.player;
  const aoeR=skill.aoeRadius||0;

  // Check hit on enemy
  let hitEnemy=false;
  if(enemy.alive){
    const d=dist(target,{x:enemy.x,y:enemy.y});
    if(d<=aoeR){
      const dmg=calcDmg(raw,'magic',enemy);
      applyDmg(enemy,dmg);hitEnemy=true;
      const tl=enemy.team==='blue'?'ğŸ”µ':'ğŸ”´';
      if(key==='r'){
        screenShake();ultFlash(caster.team==='blue'?'rgba(100,0,255,0.4)':'rgba(255,0,100,0.4)');
        spawnParticles(25,caster.team==='blue'?'#8844ff':'#ff4488');
        log(`ğŸ”¥ğŸ§¸ ${cl} ì†Œí™˜:í‹°ë²„!! â†’ ${tl} ${dmg} ì ì¤‘!`,'log-ult');
      } else {
        log(`${cl} ${ANNIE.skills[key].key} â†’ ${tl} ${dmg} ì ì¤‘!`,'log-dmg');
      }
      if(willStun){enemy.stunned=true;log(`âš¡ íŒŒì´ë¡œë§¤ë‹ˆì•„! ìŠ¤í„´!`,'log-kill');}
      if(!enemy.alive){caster.gold+=300;grantXP(caster,CHAMPION_KILL_XP);log(`${cl} ì±”í”¼ì–¸ ì²˜ì¹˜!`,'log-kill');}
      if(key==='q'&&!enemy.alive){caster.mp=Math.min(caster.maxMp,caster.mp+skill.manaCost);log('ğŸ’° Q ì²˜ì¹˜ ë§ˆë‚˜ íšŒë³µ!','log-heal');}
    }
  }

  // Check minions in AoE
  state.minions.filter(m=>m.alive&&dist(target,{x:m.x,y:m.y})<=aoeR).forEach(m=>{
    m.alive=false;grantXP(caster,MINION_XP);caster.gold+=MINION_GOLD;
    log(`${cl} ë¯¸ë‹ˆì–¸ ì²˜ì¹˜ (${m.x},${m.y}) +${MINION_GOLD}G`,'log-kill');
  });

  // Check buff monsters in AoE
  state.buffs.filter(b=>b.alive&&dist(target,{x:b.x,y:b.y})<=aoeR).forEach(b=>{
    b.hp--;
    if(b.hp<=0){
      b.alive=false;b.lastKillTurn=state.turn;
      if(b.buffType==='red'){caster.redBuff=BUFF_DURATION;log(`${cl} ğŸ”´ ë ˆë“œ ë²„í”„ íšë“!`,'log-kill');}
      else{caster.blueBuff=BUFF_DURATION;log(`${cl} ğŸ”µ ë¸”ë£¨ ë²„í”„ íšë“!`,'log-kill');}
      grantXP(caster,BUFF_XP);caster.gold+=BUFF_GOLD;
    }
  });

  // Check tibbers
  state.tibbersList.filter(t=>t.alive&&t.team!==caster.team&&dist(target,{x:t.x,y:t.y})<=aoeR).forEach(t=>{
    const dmg=calcDmg(raw,'magic',t);applyDmg(t,dmg);
  });

  if(!hitEnemy&&key!=='r'){
    log(`${cl} ${ANNIE.skills[key].key} â†’ (${target.x},${target.y}) ë¹—ë‚˜ê°`,'log-miss');
  }

  // Summon tibbers
  if(key==='r'&&skill.summon&&!caster.tibbers){
    if(!hitEnemy){
      log(`ğŸ”¥ğŸ§¸ ${cl} ì†Œí™˜:í‹°ë²„!! â†’ (${target.x},${target.y})`,'log-ult');
      screenShake();ultFlash(caster.team==='blue'?'rgba(100,0,255,0.4)':'rgba(255,0,100,0.4)');
    }
    const tib={type:'tibbers',team:caster.team,x:target.x,y:target.y,hp:300,maxHp:300,ad:40,alive:true,armor:0,mr:0};
    caster.tibbers=tib;state.tibbersList.push(tib);
  }
}

// ============ TIBBERS AI ============
function tibbersAI(){
  for(const tib of state.tibbersList){
    if(!tib.alive)continue;
    const enemy=tib.team==='blue'?state.enemy:state.player;
    if(enemy.alive&&dist({x:tib.x,y:tib.y},{x:enemy.x,y:enemy.y})<=1){
      const dmg=calcDmg(tib.ad,'physical',enemy);applyDmg(enemy,dmg);
      log(`ğŸ§¸ í‹°ë²„ â†’ ${enemy.team==='blue'?'ğŸ”µ':'ğŸ”´'} ${dmg}`,'log-dmg');
      if(!enemy.alive)log('ğŸ§¸ í‹°ë²„ê°€ ì±”í”¼ì–¸ ì²˜ì¹˜!','log-kill');
    }else if(enemy.alive){
      const dx=Math.sign(enemy.x-tib.x),dy=Math.sign(enemy.y-tib.y);
      if(dx!==0&&isWalkable(tib.x+dx,tib.y))tib.x+=dx;
      else if(dy!==0&&isWalkable(tib.x,tib.y+dy))tib.y+=dy;
    }
  }
}

function cleanDead(){
  state.tibbersList=state.tibbersList.filter(t=>t.alive);
  if(state.player.tibbers&&!state.player.tibbers.alive)state.player.tibbers=null;
  if(state.enemy.tibbers&&!state.enemy.tibbers.alive)state.enemy.tibbers=null;
}

// ============ EFFECTS ============
function screenShake(){document.getElementById('game').classList.add('screen-shake');setTimeout(()=>document.getElementById('game').classList.remove('screen-shake'),400);}
function ultFlash(c){const o=document.getElementById('ult-overlay');o.style.background=c;o.classList.add('flash');setTimeout(()=>o.classList.remove('flash'),200);}
function spawnParticles(n,c){for(let i=0;i<n;i++){const p=document.createElement('div');p.className='particle';const s=4+Math.random()*8;p.style.width=s+'px';p.style.height=s+'px';p.style.background=c;p.style.boxShadow=`0 0 ${s}px ${c}`;p.style.left=(20+Math.random()*60)+'vw';p.style.top=(20+Math.random()*60)+'vh';document.body.appendChild(p);setTimeout(()=>p.remove(),1500);}}
function showGameOver(v){
  const ov=document.getElementById('game-over-overlay'),txt=document.getElementById('game-over-text'),sub=document.getElementById('game-over-sub');
  if(v){ov.classList.add('show','victory');txt.textContent='VICTORY';sub.textContent='ì  ì±”í”¼ì–¸ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!';spawnParticles(40,'#f0c040');setTimeout(()=>spawnParticles(30,'#ff8800'),300);}
  else{ov.classList.add('show','defeat');txt.textContent='DEFEAT';sub.textContent='ì±”í”¼ì–¸ì´ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...';screenShake();setTimeout(()=>screenShake(),300);}
}
function checkGameOver(){
  if(!state.player.alive){state.gameOver=true;showGameOver(false);return true;}
  if(!state.enemy.alive){state.gameOver=true;showGameOver(true);return true;}
  return false;
}

// ============ RENDER ============
function render(){renderMap();renderStats();renderPhase();renderActions();renderLog();}

function renderMap(){
  const mapEl=document.getElementById('map');
  const p=state.player;
  const isRevealTurn=state.lastRevealTurn===state.turn||(state.lastRevealTurn===state.turn-1);
  const revealPos=state.lastEnemyReveal;

  // Target mode cells
  const targetCells=new Set();
  const moveCells=new Set();
  if(state.targetMode){
    if(state.targetMode.type==='move'){
      const dirs=[[0,-1],[0,1],[-1,0],[1,0]];
      for(const[dx,dy]of dirs){const nx=p.x+dx,ny=p.y+dy;if(isWalkable(nx,ny))moveCells.add(nx+','+ny);}
    }else{
      const range=state.targetMode.range||3;
      for(let y=1;y<ROWS-1;y++)for(let x=1;x<COLS-1;x++){
        if(dist({x:p.x,y:p.y},{x,y})<=range)targetCells.add(x+','+y);
      }
    }
  }

  let html='<table>';
  // Column headers
  html+='<tr><td class="wall" style="width:24px;height:24px;font-size:9px;color:#555"></td>';
  for(let x=0;x<COLS;x++)html+=`<td class="wall" style="height:24px;font-size:9px;color:#555;border:none">${x}</td>`;
  html+='</tr>';
  for(let y=0;y<ROWS;y++){
    html+=`<tr><td class="wall" style="width:24px;font-size:9px;color:#555;border:none">${y}</td>`;
    for(let x=0;x<COLS;x++){
      const w=MAP[y][x]===0;
      let cls=w?'wall':'walkable';
      const k=x+','+y;
      if(moveCells.has(k))cls+=' highlight';
      else if(targetCells.has(k))cls+=' target-mode';
      // Reveal flash
      if(isRevealTurn&&revealPos&&revealPos.x===x&&revealPos.y===y)cls+=' reveal-flash';

      let content='';

      // Player
      if(p.alive&&p.x===x&&p.y===y){
        content=`<span class="unit">ğŸ˜ˆ</span><span class="sub">ğŸ”µ</span>`;
      }
      // Player's tibbers
      const myTib=state.tibbersList.find(t=>t.alive&&t.team==='blue'&&t.x===x&&t.y===y);
      if(myTib)content=`<span class="unit">ğŸ§¸</span><span class="sub">ğŸ”µ</span>`;

      // Enemy tibbers (visible)
      const eTib=state.tibbersList.find(t=>t.alive&&t.team==='red'&&t.x===x&&t.y===y);
      if(eTib)content=`<span class="unit">ğŸ§¸</span><span class="sub">ğŸ”´</span>`;

      // Last known enemy position (ghost)
      if(revealPos&&revealPos.x===x&&revealPos.y===y&&!isRevealTurn&&state.turn-state.lastRevealTurn<=3){
        if(!content)content=`<span class="unit ghost">ğŸ‘»</span><span class="sub" style="color:#ff444488">ğŸ”´?</span>`;
      }
      // Reveal current position
      if(isRevealTurn&&state.enemy.alive&&state.enemy.x===x&&state.enemy.y===y){
        content=`<span class="unit">ğŸ˜ˆ</span><span class="sub">ğŸ”´</span>`;
      }

      // Buff monsters
      const buff=state.buffs.find(b=>b.alive&&b.x===x&&b.y===y);
      if(buff&&!content){content=`<span class="unit">${buff.buffType==='red'?'ğŸ”´':'ğŸ”µ'}</span><span class="sub">${buff.hp}/${buff.maxHp}</span>`;}
      else if(buff&&content){content+=`<span style="font-size:8px">${buff.buffType==='red'?'ğŸ”´':'ğŸ”µ'}</span>`;}

      // Minions
      const minion=state.minions.find(m=>m.alive&&m.x===x&&m.y===y);
      if(minion&&!content){content=`<span class="minion-marker">ğŸŸ¡</span>`;}
      else if(minion&&content){content+=`<span style="font-size:8px">ğŸŸ¡</span>`;}

      const onclick=(moveCells.has(k)||targetCells.has(k))?`onclick="selectCell(${x},${y})"`:'';
      html+=`<td class="${cls}" ${onclick}>${content}</td>`;
    }
    html+='</tr>';
  }
  html+='</table>';
  mapEl.innerHTML=html;
}

function renderStats(){
  const renderPanel=(c,label,id,showFull)=>{
    const hpPct=Math.max(0,(c.hp/c.maxHp)*100);
    const mpPct=Math.max(0,(c.mp/c.maxMp)*100);
    const needed=ANNIE.skills.passive.stacksNeeded;
    let stacks='';for(let i=0;i<needed;i++){const cls=i<c.passiveStacks?(c.passiveStacks>=needed-1?'stack ready':'stack filled'):'stack';stacks+=`<span class="${cls}"></span>`;}
    const xpN=c.level<MAX_LEVEL?XP_PER_LEVEL[c.level]:0;
    const xpP=xpN>0?Math.floor((c.xp/xpN)*100):100;
    const badges=['q','w','e','r'].map(k=>{const s=ANNIE.skills[k];const sl=c.skillLevels[k];const cd=c.cooldowns[k];if(sl<=0)return`<span class="skill-badge on-cd">${s.key}(-)</span>`;if(cd>0)return`<span class="skill-badge on-cd">${s.key}${sl}(${cd})</span>`;if(c.mp<s.manaCost)return`<span class="skill-badge on-cd">${s.key}${sl}</span>`;return`<span class="skill-badge ready">${s.key}${sl}</span>`;}).join('');

    if(showFull){
      document.getElementById(id).innerHTML=`
        <h3>${label} <span style="color:#f0c040;font-size:11px">Lv.${c.level}</span> <span style="color:#f0c040;font-size:10px">ğŸ’°${c.gold}G</span></h3>
        <div class="bar-container bar-hp"><div class="bar-fill" style="width:${hpPct}%"></div><div class="bar-label">â¤ï¸ ${c.hp}/${c.maxHp}${c.shield>0?' ğŸ›¡ï¸'+c.shield:''}</div></div>
        <div class="bar-container bar-mp"><div class="bar-fill" style="width:${mpPct}%"></div><div class="bar-label">ğŸ’§ ${c.mp}/${c.maxMp}</div></div>
        <div class="bar-container" style="height:10px;margin-bottom:4px"><div class="bar-fill" style="width:${xpP}%;background:linear-gradient(90deg,#8844aa,#cc66ff)"></div><div class="bar-label" style="font-size:8px">â­ ${c.level<MAX_LEVEL?c.xp+'/'+xpN:'MAX'}</div></div>
        <div class="passive-bar">ğŸ”¥ ${stacks}${c.redBuff>0?` <span style="color:#ff4444;font-size:10px">ğŸ”´ë ˆë“œ(${c.redBuff})</span>`:''}${c.blueBuff>0?` <span style="color:#4488ff;font-size:10px">ğŸ”µë¸”ë£¨(${c.blueBuff})</span>`:''}</div>
        <div class="skill-row">${badges}</div>
        ${c.stunned?'<div style="color:#ff44ff;margin-top:3px;font-size:11px">âš¡ ìŠ¤í„´!</div>':''}
      `;
    } else {
      // Enemy: show last known info or unknown
      const r=state.lastEnemyReveal;
      if(r){
        const hpP2=Math.max(0,(r.hp/r.maxHp)*100);
        const mpP2=Math.max(0,(r.mp/r.maxMp)*100);
        document.getElementById(id).innerHTML=`
          <h3>${label} <span style="color:#f0c040;font-size:11px">Lv.${r.level}</span></h3>
          <div class="enemy-unknown">ë§ˆì§€ë§‰ ì •ë³´ (í„´ ${state.lastRevealTurn})</div>
          <div class="bar-container bar-hp"><div class="bar-fill" style="width:${hpP2}%"></div><div class="bar-label">â¤ï¸ ${r.hp}/${r.maxHp}</div></div>
          <div class="bar-container bar-mp"><div class="bar-fill" style="width:${mpP2}%"></div><div class="bar-label">ğŸ’§ ${r.mp}/${r.maxMp}</div></div>
        `;
      } else {
        document.getElementById(id).innerHTML=`
          <h3>${label}</h3>
          <div class="enemy-unknown">ğŸ‘ï¸ ì •ë³´ ì—†ìŒ â€” ${REVEAL_INTERVAL}í„´ë§ˆë‹¤ ê³µê°œ</div>
        `;
      }
    }
  };
  renderPanel(state.player,'ğŸ”µ Annie (ë‚˜)','player-stats',true);
  renderPanel(state.enemy,'ğŸ”´ Annie (ì )','enemy-stats',false);

  // Skill level-up
  const p=state.player;
  if(p.skillPoints>0&&p.alive){
    let h=`<div class="skill-lvlup"><span style="font-size:10px;color:#f0c040;margin-right:4px">â¬†ï¸ ìŠ¤í‚¬ í¬ì¸íŠ¸: ${p.skillPoints}</span>`;
    for(const k of['q','w','e','r'])if(canLvlSkill(p,k))h+=`<button onclick="lvlSkill(state.player,'${k}')">${ANNIE.skills[k].key}â†‘</button>`;
    h+='</div>';
    document.getElementById('player-stats').innerHTML+=h;
  }
}

function renderPhase(){
  const el=document.getElementById('phase-bar');
  if(state.gameOver){el.innerHTML='';return;}

  const revealIn=REVEAL_INTERVAL-(state.turn%REVEAL_INTERVAL);
  const revealText=revealIn===REVEAL_INTERVAL?'ğŸ‘ï¸ ì´ë²ˆ í„´ì— ì  ìœ„ì¹˜ ê³µê°œ!':`ğŸ‘ï¸ ì  ìœ„ì¹˜ ê³µê°œê¹Œì§€ ${revealIn}í„´`;

  let html=`<div class="phase-title">í„´ ${state.turn} â€” ${revealText}</div>`;
  html+=`<div class="ai-action">ğŸ”´ AI í–‰ë™: ${state.aiAction?state.aiAction.desc:'...'} ${state.aiLocked?'ğŸ”’':''}</div>`;
  html+=`<div class="player-action">ğŸ”µ ë‚´ í–‰ë™: ${state.playerAction?state.playerAction.desc:'ì„ íƒí•˜ì„¸ìš”'} ${state.playerLocked?'ğŸ”’':''}</div>`;
  if(state.aiLocked&&!state.playerLocked){
    html+=`<div style="color:#f0c040;font-size:11px;margin-top:4px">âš ï¸ AIê°€ í–‰ë™ì„ ë³€ê²½í–ˆìŠµë‹ˆë‹¤! ë‹¤ì‹œ ì„ íƒí•˜ê±°ë‚˜ í™•ì •í•˜ì„¸ìš”.</div>`;
  }
  el.innerHTML=html;
}

function renderActions(){
  const el=document.getElementById('actions');
  const p=state.player;
  if(state.gameOver||!p.alive){el.innerHTML='';return;}

  if(state.targetMode){
    let label='';
    if(state.targetMode.type==='move')label='ì´ë™í•  ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”';
    else if(state.targetMode.type==='attack')label='ê³µê²©í•  ì¢Œí‘œë¥¼ ì„ íƒí•˜ì„¸ìš”';
    else label=`${ANNIE.skills[state.targetMode.key].key} ëŒ€ìƒ ì¢Œí‘œë¥¼ ì„ íƒí•˜ì„¸ìš”`;
    el.innerHTML=`<span style="color:#f0c040;font-size:12px">${label}</span> <button class="cancel" onclick="cancelTarget()">âŒ ì·¨ì†Œ</button>`;
    return;
  }

  if(p.stunned){
    state.playerAction={type:'wait',desc:'âš¡ ìŠ¤í„´ ìƒíƒœ'};
    el.innerHTML=`<button class="confirm" onclick="confirmActions()">âš¡ ìŠ¤í„´ â€” í™•ì •</button>`;
    return;
  }

  const can=k=>p.skillLevels[k]>0&&p.cooldowns[k]===0&&p.mp>=ANNIE.skills[k].manaCost;
  let html=`
    <button class="move" onclick="setPlayerMove()">ğŸš¶ ì´ë™</button>
    <button class="attack" onclick="setPlayerAttack()">âš”ï¸ í‰íƒ€</button>
    <button class="skill-q" onclick="setPlayerSkill('q')" ${!can('q')?'disabled':''}>Q ë¶•ê´´</button>
    <button class="skill-w" onclick="setPlayerSkill('w')" ${!can('w')?'disabled':''}>W ì†Œê°</button>
    <button class="skill-e" onclick="setPlayerSkill('e')" ${!can('e')?'disabled':''}>E ë³´í˜¸ë§‰</button>
    <button class="skill-r" onclick="setPlayerSkill('r')" ${!can('r')?'disabled':''}>ğŸ”¥ R í‹°ë²„</button>
  `;
  if(state.playerAction){
    if(state.aiLocked&&!state.playerLocked){
      // AI reacted, player can re-choose or accept
      html+=`<button class="confirm" onclick="finalConfirm()">âœ… ì´ëŒ€ë¡œ í™•ì •</button>`;
    } else {
      html+=`<button class="confirm" onclick="confirmActions()">âœ… í™•ì •</button>`;
    }
  }
  el.innerHTML=html;
}

function renderLog(){
  const el=document.getElementById('log');
  const recent=state.logs.slice(-60);
  el.innerHTML=recent.map(l=>`<div class="${l.cls}">${l.msg}</div>`).join('');
  el.scrollTop=el.scrollHeight;
}

initGame();
</script>
</body>
</html>
