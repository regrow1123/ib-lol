<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ib-lol</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a1a; color: #e0e0e0; font-family: 'Courier New', monospace; font-size: 14px; overflow-x: hidden; }
#game { max-width: 960px; margin: 0 auto; padding: 16px; position: relative; }
h1 { text-align: center; color: #f0c040; margin-bottom: 2px; font-size: 22px; }
.subtitle { text-align: center; color: #888; margin-bottom: 12px; font-size: 11px; }

/* Grid map */
#map { display: flex; justify-content: center; margin-bottom: 12px; }
#map table { border-collapse: collapse; }
#map td {
  width: 52px; height: 52px; border: 1px solid #222; text-align: center; vertical-align: middle;
  font-size: 18px; position: relative; background: #0d0d0d; cursor: default;
  transition: background 0.15s;
}
#map td.lane { background: #111a11; border-color: #1a2a1a; }
#map td.grass { background: #0a1a0a; border-color: #1a2a1a; }
#map td.wall { background: #1a1a1a; border-color: #222; }
#map td.tower-blue { background: #0a0a2a; border-color: #224; }
#map td.tower-red { background: #2a0a0a; border-color: #422; }
#map td.highlight { background: #333300 !important; border-color: #555500; cursor: pointer; }
#map td .unit { display: block; line-height: 1.2; }
#map td .sub { font-size: 9px; display: block; color: #aaa; }
#map td .hp-mini { font-size: 8px; color: #4f4; }

/* Stats */
.stats-row { display: flex; gap: 8px; margin-bottom: 10px; }
.stat-panel { flex: 1; background: #111; border: 1px solid #333; padding: 10px; border-radius: 4px; }
.stat-panel.player { border-color: #4488ff; }
.stat-panel.enemy { border-color: #ff4444; }
.stat-panel h3 { margin-bottom: 6px; font-size: 13px; }
.bar-container { background: #222; border-radius: 3px; height: 18px; position: relative; margin-bottom: 4px; overflow: hidden; }
.bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
.bar-hp .bar-fill { background: linear-gradient(90deg, #22aa22, #44ff44); }
.bar-mp .bar-fill { background: linear-gradient(90deg, #2244aa, #4488ff); }
.bar-label { position: absolute; top: 0; left: 0; right: 0; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #fff; text-shadow: 1px 1px 2px #000; }
.passive-bar { font-size: 11px; margin-top: 3px; }
.passive-bar .stack { display: inline-block; width: 12px; height: 12px; border: 1px solid #666; border-radius: 2px; margin-right: 2px; }
.passive-bar .stack.filled { background: #ff6600; border-color: #ff8800; }
.passive-bar .stack.ready { background: #ff00ff; border-color: #ff44ff; animation: pulse 0.5s infinite alternate; }
.skill-row { display: flex; gap: 4px; margin-top: 4px; }
.skill-badge { font-size: 10px; padding: 2px 5px; border-radius: 3px; background: #1a1a1a; border: 1px solid #444; }
.skill-badge.on-cd { opacity: 0.35; }
.skill-badge.ready { border-color: #44ff44; color: #44ff44; }
.skill-lvlup { display: flex; gap: 4px; margin-top: 4px; }
.skill-lvlup button { font-size: 10px; padding: 2px 8px; background: #1a1a00; border: 1px solid #f0c040; color: #f0c040; border-radius: 3px; cursor: pointer; font-family: inherit; animation: pulse 0.8s infinite alternate; }
.skill-lvlup button:hover { background: #333300; }

/* Log */
#log { background: #0a0a0a; border: 1px solid #333; padding: 8px; height: 150px; overflow-y: auto; margin-bottom: 10px; border-radius: 4px; font-size: 11px; line-height: 1.5; }
.log-turn { color: #f0c040; font-weight: bold; }
.log-dmg { color: #ff6644; }
.log-heal { color: #44ff44; }
.log-info { color: #88aaff; }
.log-kill { color: #ff44ff; }
.log-ult { color: #ff00ff; font-weight: bold; }

/* Actions */
#actions { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px; }
#actions button { background: #222; color: #e0e0e0; border: 1px solid #555; padding: 7px 14px; cursor: pointer; border-radius: 4px; font-family: inherit; font-size: 12px; transition: all 0.15s; }
#actions button:hover:not(:disabled) { background: #333; border-color: #aaa; }
#actions button:disabled { opacity: 0.3; cursor: not-allowed; }
#actions button.move { border-color: #44aa44; }
#actions button.attack { border-color: #ff6644; }
#actions button.skill-q { border-color: #ff8800; }
#actions button.skill-w { border-color: #ff4444; }
#actions button.skill-e { border-color: #44aaff; }
#actions button.skill-r { border-color: #ff00ff; background: #1a0020; }
#actions button.skill-r:hover:not(:disabled) { background: #2a0040; box-shadow: 0 0 10px #ff00ff44; }

/* Target select */
#target-select { background: #1a1a0a; border: 1px solid #f0c040; padding: 8px; margin-bottom: 10px; border-radius: 4px; display: none; }
#target-select h4 { color: #f0c040; margin-bottom: 6px; font-size: 12px; }
#target-select button { background: #222; color: #e0e0e0; border: 1px solid #555; padding: 5px 10px; margin: 2px; cursor: pointer; border-radius: 4px; font-family: inherit; font-size: 11px; }
#target-select button:hover { background: #333; }

/* Effects */
#ult-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 100; opacity: 0; transition: opacity 0.15s; }
#ult-overlay.flash { opacity: 1; }
@keyframes shake { 0%,100%{transform:translate(0,0)}10%{transform:translate(-6px,3px)}30%{transform:translate(4px,-4px)}50%{transform:translate(-3px,5px)}70%{transform:translate(5px,-2px)}90%{transform:translate(-4px,2px)} }
.screen-shake { animation: shake 0.4s ease; }
@keyframes pulse { from{opacity:0.6}to{opacity:1} }

/* Game over */
#game-over-overlay { display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:200; justify-content:center; align-items:center; flex-direction:column; }
#game-over-overlay.show { display:flex; }
#game-over-overlay.victory { background: radial-gradient(ellipse at center, rgba(255,200,0,0.3) 0%, rgba(0,0,0,0.9) 70%); }
#game-over-overlay.defeat { background: radial-gradient(ellipse at center, rgba(255,0,0,0.2) 0%, rgba(0,0,0,0.95) 70%); }
#game-over-text { font-size: 56px; font-weight: bold; letter-spacing: 8px; margin-bottom: 16px; animation: resultAppear 0.8s ease-out; }
#game-over-overlay.victory #game-over-text { color: #f0c040; text-shadow: 0 0 30px #f0c040, 0 0 60px #ff8800; }
#game-over-overlay.defeat #game-over-text { color: #ff2222; text-shadow: 0 0 30px #ff0000, 0 0 60px #880000; }
#game-over-sub { font-size: 14px; color: #aaa; margin-bottom: 24px; animation: resultAppear 1s ease-out; }
#game-over-overlay button { background:none; border:2px solid #888; color:#e0e0e0; padding:10px 36px; font-size:16px; cursor:pointer; border-radius:4px; font-family:inherit; animation: resultAppear 1.2s ease-out; }
#game-over-overlay button:hover { border-color:#f0c040; color:#f0c040; }
@keyframes resultAppear { 0%{opacity:0;transform:scale(0.5) translateY(20px)}100%{opacity:1;transform:scale(1) translateY(0)} }

.particle { position:fixed; pointer-events:none; z-index:90; border-radius:50%; animation: particleFly 1s ease-out forwards; }
@keyframes particleFly { 0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0) translateY(-100px)} }
</style>
</head>
<body>
<div id="game">
  <h1>âš”ï¸ ib-lol âš”ï¸</h1>
  <div class="subtitle">í„´ì œ 1v1 ë¼ì¸ì „ â€” Annie Mirror Match</div>
  <div id="map"></div>
  <div class="stats-row">
    <div class="stat-panel player" id="player-stats"></div>
    <div class="stat-panel enemy" id="enemy-stats"></div>
  </div>
  <div id="target-select"><h4>ğŸ¯ íƒ€ê²Ÿ ì„ íƒ</h4><div id="target-buttons"></div></div>
  <div id="actions"></div>
  <div id="log"></div>
</div>
<div id="ult-overlay"></div>
<div id="game-over-overlay">
  <div id="game-over-text"></div>
  <div id="game-over-sub"></div>
  <button onclick="restartGame()">ë‹¤ì‹œ í•˜ê¸°</button>
</div>

<script>
// ============ CONFIG ============
const COLS = 15, ROWS = 7;
const MID_ROW = 3; // lane row (0-indexed)

// Map layout: 0=wall, 1=lane, 2=grass
const MAP_TEMPLATE = [
  [0,0,0,2,2,2,2,0,2,2,2,2,0,0,0],
  [0,0,2,2,1,1,1,1,1,1,1,2,2,0,0],
  [0,2,2,1,1,1,1,1,1,1,1,1,2,2,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,2,2,1,1,1,1,1,1,1,1,1,2,2,0],
  [0,0,2,2,1,1,1,1,1,1,1,2,2,0,0],
  [0,0,0,2,2,2,2,0,2,2,2,2,0,0,0],
];

const TOWER_HP = 1500, TOWER_DMG = 80, TOWER_RANGE = 2;
const MINION_HP = 300, MINION_DMG = 15, MINION_GOLD = 20, MINION_SPAWN_INTERVAL = 3;

const ANNIE = {
  name:'Annie', hp:560, mp:418, ad:50, ap:0, armor:19, mr:30,
  // Per-level growth
  hpPerLvl: 88, mpPerLvl: 25, adPerLvl: 2.7, apPerLvl: 0, armorPerLvl: 4, mrPerLvl: 1.3,
  skills: {
    passive: { name:'íŒŒì´ë¡œë§¤ë‹ˆì•„', stacksNeeded:4 },
    q: { name:'ë¶•ê´´', key:'Q', baseDmg:[80,115,150,185,220], manaCost:60, cooldown:0, range:3, type:'target' },
    w: { name:'ì†Œê°', key:'W', baseDmg:[70,115,160,205,250], manaCost:70, cooldown:1, range:2, type:'target' },
    e: { name:'ë³´í˜¸ë§‰', key:'E', baseShield:[40,65,90,115,140], shieldApRatio:0.4, manaCost:40, cooldown:3, type:'self' },
    r: { name:'í‹°ë²„', key:'R', baseDmg:[150,275,400], manaCost:100, cooldown:8, range:3, type:'target', summon:true }
  }
};

// Level/XP config
const MAX_LEVEL = 18;
const XP_PER_LEVEL = [0,280,380,480,580,680,780,880,980,1080,1180,1280,1380,1480,1580,1680,1780,1880];
const MINION_XP = 60;
const CHAMPION_KILL_XP = 200;
const SKILL_MAX = {q:5, w:5, e:5, r:3};
const R_UNLOCK_LEVELS = [6, 11, 16]; // levels at which R can be leveled

function getSkillDamage(key, skillLvl) {
  const s = ANNIE.skills[key];
  if (!s.baseDmg || skillLvl <= 0) return 0;
  return s.baseDmg[Math.min(skillLvl - 1, s.baseDmg.length - 1)] || 0;
}
function getSkillShield(skillLvl) {
  const s = ANNIE.skills.e;
  if (skillLvl <= 0) return 0;
  return s.baseShield[Math.min(skillLvl - 1, s.baseShield.length - 1)] || 0;
}
function canLevelSkill(champ, key) {
  if (champ.skillPoints <= 0) return false;
  if (champ.skillLevels[key] >= SKILL_MAX[key]) return false;
  if (key === 'r') {
    // R can only be leveled at 6, 11, 16
    const rLvl = champ.skillLevels.r;
    if (rLvl >= 3) return false;
    if (champ.level < R_UNLOCK_LEVELS[rLvl]) return false;
    return true;
  }
  // Normal skills can't exceed ceil(level/2) ... simplified: just max check
  return true;
}
function levelUpSkill(champ, key) {
  if (!canLevelSkill(champ, key)) return;
  champ.skillLevels[key]++;
  champ.skillPoints--;
  const cl = champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
  log(`â¬†ï¸ ${cl} ${ANNIE.skills[key].key} ìŠ¤í‚¬ ë ˆë²¨ ì—…! â†’ Lv.${champ.skillLevels[key]}`, 'log-heal');
  render();
}
// AI auto skill order
const AI_SKILL_ORDER = ['q','w','q','e','q','r','w','w','q','w','e','r','q','w','e','r','e','e'];
function aiAutoLevelSkills(champ) {
  while (champ.skillPoints > 0) {
    const totalUsed = champ.skillLevels.q + champ.skillLevels.w + champ.skillLevels.e + champ.skillLevels.r;
    const nextSkill = AI_SKILL_ORDER[totalUsed];
    if (nextSkill && canLevelSkill(champ, nextSkill)) {
      champ.skillLevels[nextSkill]++;
      champ.skillPoints--;
    } else break;
  }
}

// ============ UTIL ============
function dist(a, b) { return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); } // Manhattan
function isWalkable(x, y) { return x>=0 && x<COLS && y>=0 && y<ROWS && MAP_TEMPLATE[y][x] !== 0; }

// ============ STATE ============
let state;

function createChamp(t, team, x, y) {
  const c = { type:'champion', team, name:t.name, x, y, baseHp:t.hp, baseMp:t.mp, baseAd:t.ad, baseAp:t.ap, baseArmor:t.armor, baseMr:t.mr,
    maxHp:t.hp, hp:t.hp, maxMp:t.mp, mp:t.mp, ad:t.ad, ap:t.ap, armor:t.armor, mr:t.mr,
    level:1, xp:0, skillPoints:1, skillLevels:{q:0,w:0,e:0,r:0},
    passiveStacks:0, shield:0, cooldowns:{q:0,w:0,e:0,r:0}, tibbers:null, gold:0, alive:true, stunned:false };
  recalcStats(c);
  return c;
}
function recalcStats(c) {
  const lvl = c.level;
  c.maxHp = Math.floor(c.baseHp + ANNIE.hpPerLvl * (lvl - 1));
  c.maxMp = Math.floor(c.baseMp + ANNIE.mpPerLvl * (lvl - 1));
  c.ad = Math.floor(c.baseAd + ANNIE.adPerLvl * (lvl - 1));
  c.armor = Math.floor(c.baseArmor + ANNIE.armorPerLvl * (lvl - 1));
  c.mr = Math.floor(c.baseMr + ANNIE.mrPerLvl * (lvl - 1));
}
function grantXP(champ, amount) {
  if (champ.level >= MAX_LEVEL) return;
  champ.xp += amount;
  while (champ.level < MAX_LEVEL && champ.xp >= XP_PER_LEVEL[champ.level]) {
    champ.xp -= XP_PER_LEVEL[champ.level];
    champ.level++;
    champ.skillPoints++;
    const oldMaxHp = champ.maxHp, oldMaxMp = champ.maxMp;
    recalcStats(champ);
    champ.hp += champ.maxHp - oldMaxHp;
    champ.mp += champ.maxMp - oldMaxMp;
    const cl = champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
    log(`â¬†ï¸ ${cl} ${champ.name} ë ˆë²¨ ì—…! Lv.${champ.level} (ìŠ¤í‚¬ í¬ì¸íŠ¸ +1)`,'log-heal');
    // AI auto-levels skills immediately
    if (champ.team === 'red') aiAutoLevelSkills(champ);
  }
}
function createTower(team, x, y) { return { type:'tower', team, x, y, hp:TOWER_HP, maxHp:TOWER_HP, alive:true, ad:TOWER_DMG, range:TOWER_RANGE, armor:0, mr:0 }; }
function createMinion(team, x, y, id) { return { type:'minion', team, x, y, hp:MINION_HP, maxHp:MINION_HP, ad:MINION_DMG, alive:true, id, armor:0, mr:0 }; }

function initGame() {
  state = {
    turn: 1,
    player: createChamp(ANNIE, 'blue', 3, MID_ROW),
    enemy: createChamp(ANNIE, 'red', 11, MID_ROW),
    towers: [createTower('blue', 1, MID_ROW), createTower('red', 13, MID_ROW)],
    minions: [], tibbersList: [], minionIdCounter: 0,
    logs: [], phase: 'action', gameOver: false,
    moveMode: false
  };
  aiAutoLevelSkills(state.enemy); // AI uses starting skill point
  spawnMinions();
  log(`â”â”â” í„´ ${state.turn} â”â”â”`, 'log-turn');
  render();
}
function restartGame() {
  document.getElementById('game-over-overlay').classList.remove('show','victory','defeat');
  initGame();
}

function log(msg, cls='') { state.logs.push({msg, cls}); }

function calcDmg(raw, type, target) {
  const def = type==='magic' ? (target.mr||0) : (target.armor||0);
  return Math.max(1, Math.floor(raw * (100/(100+def))));
}
function applyDmg(target, amount) {
  if (target.shield > 0) { if (target.shield >= amount) { target.shield -= amount; return 0; } amount -= target.shield; target.shield = 0; }
  target.hp = Math.max(0, target.hp - amount);
  if (target.hp <= 0) target.alive = false;
  return amount;
}

function spawnMinions() {
  if (state.turn % MINION_SPAWN_INTERVAL === 1 || state.turn === 1) {
    state.minionIdCounter++;
    state.minions.push(createMinion('blue', 2, MID_ROW, 'B'+state.minionIdCounter));
    state.minionIdCounter++;
    state.minions.push(createMinion('red', 12, MID_ROW, 'R'+state.minionIdCounter));
    log('ğŸ° ë¯¸ë‹ˆì–¸ ìƒì„±!', 'log-info');
  }
}

// ============ EFFECTS ============
function screenShake() { document.getElementById('game').classList.add('screen-shake'); setTimeout(()=>document.getElementById('game').classList.remove('screen-shake'),400); }
function ultFlash(color) { const o=document.getElementById('ult-overlay'); o.style.background=color; o.classList.add('flash'); screenShake(); setTimeout(()=>o.classList.remove('flash'),200); }
function spawnParticles(n, color) {
  for(let i=0;i<n;i++){const p=document.createElement('div');p.className='particle';const s=4+Math.random()*8;p.style.width=s+'px';p.style.height=s+'px';p.style.background=color;p.style.boxShadow=`0 0 ${s}px ${color}`;p.style.left=(20+Math.random()*60)+'vw';p.style.top=(20+Math.random()*60)+'vh';document.body.appendChild(p);setTimeout(()=>p.remove(),1500);}
}
function showGameOver(victory) {
  const ov=document.getElementById('game-over-overlay'), txt=document.getElementById('game-over-text'), sub=document.getElementById('game-over-sub');
  if(victory){ov.classList.add('show','victory');txt.textContent='VICTORY';sub.textContent=!state.enemy.alive?'ì  ì±”í”¼ì–¸ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!':'ì  íƒ€ì›Œë¥¼ íŒŒê´´í–ˆìŠµë‹ˆë‹¤!';spawnParticles(40,'#f0c040');setTimeout(()=>spawnParticles(30,'#ff8800'),300);}
  else{ov.classList.add('show','defeat');txt.textContent='DEFEAT';sub.textContent=!state.player.alive?'ì±”í”¼ì–¸ì´ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...':'ì•„êµ° íƒ€ì›Œê°€ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤...';screenShake();setTimeout(()=>screenShake(),300);}
}

// ============ SKILLS ============
function executeSkill(caster, key, target) {
  const skill = ANNIE.skills[key];
  if (caster.cooldowns[key]>0 || caster.mp<skill.manaCost) return false;
  caster.mp -= skill.manaCost;
  caster.cooldowns[key] = skill.cooldown;
  caster.passiveStacks++;
  let willStun = false;
  if (caster.passiveStacks >= ANNIE.skills.passive.stacksNeeded) { willStun=true; caster.passiveStacks=0; }
  const cl = caster.team==='blue'?'ğŸ”µ':'ğŸ”´';

  const sLvl = caster.skillLevels[key] || 0;
  if (sLvl <= 0) return false;

  if (key==='e') {
    const base = getSkillShield(sLvl);
    const s=Math.floor(base+skill.shieldApRatio*caster.ap);
    caster.shield+=s;
    log(`${cl} ${caster.name} E ë³´í˜¸ë§‰ +${s}`,'log-info');
    return true;
  }
  if (!target?.alive) return false;
  const d = dist({x:caster.x,y:caster.y},{x:target.x,y:target.y});
  if (d > skill.range) return false;

  const raw = getSkillDamage(key, sLvl) + caster.ap;
  const dmg = calcDmg(raw,'magic',target);
  applyDmg(target,dmg);
  const tl = target.team==='blue'?'ğŸ”µ':'ğŸ”´';

  if (key==='r') {
    ultFlash(caster.team==='blue'?'rgba(100,0,255,0.4)':'rgba(255,0,100,0.4)');
    spawnParticles(25, caster.team==='blue'?'#8844ff':'#ff4488');
    log(`ğŸ”¥ğŸ§¸ ${cl} ì†Œí™˜: í‹°ë²„!! â†’ ${tl}${target.name||target.type} ${dmg}`,'log-ult');
    if (!caster.tibbers) {
      const tib={type:'tibbers',team:caster.team,x:target.x,y:target.y,hp:300,maxHp:300,ad:40,alive:true,armor:0,mr:0};
      caster.tibbers=tib; state.tibbersList.push(tib);
    }
  } else {
    log(`${cl} ${caster.name} ${skill.key} â†’ ${tl}${target.name||target.type} ${dmg}`,'log-dmg');
  }

  if (willStun && target.type==='champion') { target.stunned=true; log(`âš¡ íŒŒì´ë¡œë§¤ë‹ˆì•„! ${tl}${target.name} ìŠ¤í„´!`,'log-kill'); }
  if (key==='q' && !target.alive) { caster.mp=Math.min(caster.maxMp,caster.mp+skill.manaCost); log('ğŸ’° Q ì²˜ì¹˜ ë§ˆë‚˜ íšŒë³µ!','log-heal'); }
  if (!target.alive) handleKill(caster,target);
  return true;
}

function handleKill(killer, victim) {
  const kl=killer.team==='blue'?'ğŸ”µ':'ğŸ”´';
  if(victim.type==='minion'){
    killer.gold+=MINION_GOLD;
    if(killer.type==='champion') grantXP(killer, MINION_XP);
    log(`${kl} ë¯¸ë‹ˆì–¸ ì²˜ì¹˜ +${MINION_GOLD}G +${MINION_XP}XP`,'log-kill');
  } else if(victim.type==='champion'){
    killer.gold+=300;
    if(killer.type==='champion') grantXP(killer, CHAMPION_KILL_XP);
    log(`${kl} ì±”í”¼ì–¸ ì²˜ì¹˜! +300G +${CHAMPION_KILL_XP}XP`,'log-kill');
  }
}

function autoAttack(atk, tgt) {
  if(!tgt?.alive) return false;
  const d=dist({x:atk.x,y:atk.y},{x:tgt.x,y:tgt.y});
  if(d>2) return false;
  const dmg=calcDmg(atk.ad,'physical',tgt);
  applyDmg(tgt,dmg);
  const al=atk.team==='blue'?'ğŸ”µ':'ğŸ”´', tl=tgt.team==='blue'?'ğŸ”µ':'ğŸ”´';
  log(`${al} ${atk.name||atk.type} â†’ ${tl}${tgt.name||tgt.type} ${dmg}`,'log-dmg');
  if(!tgt.alive) handleKill(atk,tgt);
  return true;
}

function getEnemyTargets(unit) {
  const et=unit.team==='blue'?'red':'blue'; let t=[];
  const ec=unit.team==='blue'?state.enemy:state.player;
  if(ec.alive)t.push(ec);
  state.minions.filter(m=>m.alive&&m.team===et).forEach(m=>t.push(m));
  state.towers.filter(tw=>tw.alive&&tw.team===et).forEach(tw=>t.push(tw));
  state.tibbersList.filter(tb=>tb.alive&&tb.team===et).forEach(tb=>t.push(tb));
  return t;
}
function getInRange(unit, range) { return getEnemyTargets(unit).filter(t=>dist({x:unit.x,y:unit.y},{x:t.x,y:t.y})<=range); }
function tgtLabel(t) {
  if(t.type==='champion')return`${t.name} (${t.hp}HP)`;
  if(t.type==='minion')return`ë¯¸ë‹ˆì–¸ (${t.hp}HP)`;
  if(t.type==='tower')return`íƒ€ì›Œ (${t.hp}HP)`;
  if(t.type==='tibbers')return`í‹°ë²„ (${t.hp}HP)`;
  return t.type;
}

// ============ PLAYER ACTIONS ============
function playerMove(dx, dy) {
  const nx=state.player.x+dx, ny=state.player.y+dy;
  if(!isWalkable(nx,ny)) return;
  // Check collision with towers
  for(const tw of state.towers) if(tw.alive&&tw.x===nx&&tw.y===ny) return;
  state.player.x=nx; state.player.y=ny;
  state.moveMode=false;
  log(`ğŸ”µ ì´ë™ â†’ (${nx},${ny})`,'log-info');
  endPlayerTurn();
}

function enterMoveMode() {
  state.moveMode = true;
  render();
}
function cancelMoveMode() {
  state.moveMode = false;
  render();
}

function playerAA() {
  const ts=getInRange(state.player,2);
  if(!ts.length){log('âš ï¸ ì‚¬ê±°ë¦¬ ë‚´ ëŒ€ìƒ ì—†ìŒ','log-info');render();return;}
  if(ts.length===1){autoAttack(state.player,ts[0]);endPlayerTurn();}
  else showTargetSelect(ts,t=>{autoAttack(state.player,t);endPlayerTurn();});
}

function playerSkill(key) {
  const p=state.player, s=ANNIE.skills[key];
  if(p.skillLevels[key]<=0)return;
  if(p.cooldowns[key]>0)return;
  if(p.mp<s.manaCost){log('âš ï¸ ë§ˆë‚˜ ë¶€ì¡±!','log-info');render();return;}
  if(s.type==='self'){executeSkill(p,key,null);endPlayerTurn();}
  else{
    const ts=getInRange(p,s.range);
    if(!ts.length){log('âš ï¸ ì‚¬ê±°ë¦¬ ë‚´ ëŒ€ìƒ ì—†ìŒ','log-info');render();return;}
    if(ts.length===1){executeSkill(p,key,ts[0]);endPlayerTurn();}
    else showTargetSelect(ts,t=>{executeSkill(p,key,t);endPlayerTurn();});
  }
}

function showTargetSelect(targets, cb) {
  state.phase='target';
  const c=document.getElementById('target-buttons');c.innerHTML='';
  const div=document.getElementById('target-select');div.style.display='block';
  targets.forEach(t=>{const b=document.createElement('button');b.textContent=tgtLabel(t);b.onclick=()=>{div.style.display='none';state.phase='action';cb(t);};c.appendChild(b);});
  const cancel=document.createElement('button');cancel.textContent='ì·¨ì†Œ';cancel.style.borderColor='#ff4444';
  cancel.onclick=()=>{div.style.display='none';state.phase='action';render();};
  c.appendChild(cancel);
  render();
}

// ============ TURN FLOW ============
function endPlayerTurn() {
  document.getElementById('target-select').style.display='none';
  state.moveMode=false;
  if(checkGameOver()){render();return;}
  aiTurn(); if(checkGameOver()){render();return;}
  minionTurns(); if(checkGameOver()){render();return;}
  towerAttacks(); if(checkGameOver()){render();return;}
  tibbersAI(); if(checkGameOver()){render();return;}

  for(let k of['q','w','e','r']){if(state.player.cooldowns[k]>0)state.player.cooldowns[k]--;if(state.enemy.cooldowns[k]>0)state.enemy.cooldowns[k]--;}
  state.player.stunned=false;state.enemy.stunned=false;
  state.player.mp=Math.min(state.player.maxMp,state.player.mp+10);
  state.enemy.mp=Math.min(state.enemy.maxMp,state.enemy.mp+10);

  state.turn++;
  spawnMinions();
  state.minions=state.minions.filter(m=>m.alive);
  state.tibbersList=state.tibbersList.filter(t=>t.alive);
  if(state.player.tibbers&&!state.player.tibbers.alive)state.player.tibbers=null;
  if(state.enemy.tibbers&&!state.enemy.tibbers.alive)state.enemy.tibbers=null;

  log(`â”â”â” í„´ ${state.turn} â”â”â”`,'log-turn');
  render();
}

// ============ AI ============
function aiTurn() {
  const ai=state.enemy;
  if(!ai.alive)return;
  if(ai.stunned){log('ğŸ”´ ìŠ¤í„´! í„´ ìŠ¤í‚µ','log-info');return;}
  const p=state.player;

  if(ai.skillLevels.r>0&&ai.cooldowns.r===0&&ai.mp>=100&&p.alive&&dist({x:ai.x,y:ai.y},{x:p.x,y:p.y})<=3){executeSkill(ai,'r',p);return;}
  if(ai.skillLevels.q>0&&ai.cooldowns.q===0&&ai.mp>=60){
    const ms=state.minions.filter(m=>m.alive&&m.team==='blue'&&dist({x:ai.x,y:ai.y},{x:m.x,y:m.y})<=3);
    const lh=ms.find(m=>m.hp<=80);
    if(lh){executeSkill(ai,'q',lh);return;}
    if(p.alive&&dist({x:ai.x,y:ai.y},{x:p.x,y:p.y})<=3){executeSkill(ai,'q',p);return;}
  }
  if(ai.skillLevels.w>0&&ai.cooldowns.w===0&&ai.mp>=70){const ts=getInRange(ai,2);if(ts.length){executeSkill(ai,'w',ts[0]);return;}}
  if(ai.skillLevels.e>0&&ai.cooldowns.e===0&&ai.shield===0&&ai.mp>=40){executeSkill(ai,'e',null);return;}

  const aa=getInRange(ai,2);
  if(aa.length){const lm=aa.find(t=>t.type==='minion'&&t.hp<=ai.ad);autoAttack(ai,lm||aa.find(t=>t.type==='champion')||aa[0]);return;}

  // Move toward player or center
  const tx=p.alive?p.x:7, ty=p.alive?p.y:MID_ROW;
  const dx=Math.sign(tx-ai.x), dy=Math.sign(ty-ai.y);
  // Try horizontal first, then vertical
  if(dx!==0&&isWalkable(ai.x+dx,ai.y)){ai.x+=dx;log(`ğŸ”´ ì´ë™ â†’ (${ai.x},${ai.y})`,'log-info');return;}
  if(dy!==0&&isWalkable(ai.x,ai.y+dy)){ai.y+=dy;log(`ğŸ”´ ì´ë™ â†’ (${ai.x},${ai.y})`,'log-info');}
}

function minionTurns() {
  for(const m of state.minions){
    if(!m.alive)continue;
    const et=m.team==='blue'?'red':'blue';
    const enemies=[...state.minions.filter(e=>e.alive&&e.team===et)];
    const ec=m.team==='blue'?state.enemy:state.player;
    if(ec.alive)enemies.push(ec);
    state.towers.filter(t=>t.alive&&t.team===et).forEach(t=>enemies.push(t));
    let closest=null,cd=999;
    for(const e of enemies){const d=dist({x:m.x,y:m.y},{x:e.x,y:e.y});if(d<cd){cd=d;closest=e;}}
    if(closest&&cd<=1){
      const dmg=calcDmg(m.ad,'physical',closest);applyDmg(closest,dmg);
      if(!closest.alive){
        if(closest.type==='champion') log('ğŸ’€ ë¯¸ë‹ˆì–¸ì´ ì±”í”¼ì–¸ ì²˜ì¹˜!','log-kill');
        // Grant XP to nearby champion (within 4 tiles) if minion died
        if(closest.type==='minion'){
          const nearBlue=dist({x:state.player.x,y:state.player.y},{x:closest.x,y:closest.y})<=4;
          const nearRed=dist({x:state.enemy.x,y:state.enemy.y},{x:closest.x,y:closest.y})<=4;
          if(nearBlue&&closest.team==='red') grantXP(state.player, Math.floor(MINION_XP*0.6));
          if(nearRed&&closest.team==='blue') grantXP(state.enemy, Math.floor(MINION_XP*0.6));
        }
      }
    } else if(closest){
      // Move toward closest enemy along lane
      const dx=Math.sign(closest.x-m.x), dy=Math.sign(closest.y-m.y);
      if(dx!==0&&isWalkable(m.x+dx,m.y)){m.x+=dx;}
      else if(dy!==0&&isWalkable(m.x,m.y+dy)){m.y+=dy;}
    }
  }
}

function towerAttacks() {
  for(const tw of state.towers){
    if(!tw.alive)continue;
    const et=tw.team==='blue'?'red':'blue';
    const ir=[];
    state.minions.filter(m=>m.alive&&m.team===et&&dist({x:tw.x,y:tw.y},{x:m.x,y:m.y})<=tw.range).forEach(m=>ir.push(m));
    const ec=tw.team==='blue'?state.enemy:state.player;
    if(ec.alive&&dist({x:tw.x,y:tw.y},{x:ec.x,y:ec.y})<=tw.range)ir.push(ec);
    state.tibbersList.filter(t=>t.alive&&t.team===et&&dist({x:tw.x,y:tw.y},{x:t.x,y:t.y})<=tw.range).forEach(t=>ir.push(t));
    if(ir.length){
      const tgt=ir.find(t=>t.type==='minion')||ir[0];
      const dmg=calcDmg(tw.ad,'physical',tgt);applyDmg(tgt,dmg);
      const tl=tw.team==='blue'?'ğŸ”µ':'ğŸ”´';
      log(`ğŸ°${tl} íƒ€ì›Œ â†’ ${tgt.name||tgt.type} ${dmg}`,'log-dmg');
    }
  }
}

function tibbersAI() {
  for(const tib of state.tibbersList){
    if(!tib.alive)continue;
    const enemies=getEnemyTargets(tib);
    let closest=null,cd=999;
    for(const e of enemies){const d=dist({x:tib.x,y:tib.y},{x:e.x,y:e.y});if(d<cd){cd=d;closest=e;}}
    if(closest&&cd<=1){const dmg=calcDmg(tib.ad,'physical',closest);applyDmg(closest,dmg);log(`ğŸ§¸ í‹°ë²„ â†’ ${closest.name||closest.type} ${dmg}`,'log-dmg');}
    else if(closest){const dx=Math.sign(closest.x-tib.x),dy=Math.sign(closest.y-tib.y);if(dx!==0&&isWalkable(tib.x+dx,tib.y))tib.x+=dx;else if(dy!==0&&isWalkable(tib.x,tib.y+dy))tib.y+=dy;}
  }
}

function checkGameOver() {
  const bt=state.towers.find(t=>t.team==='blue'),rt=state.towers.find(t=>t.team==='red');
  if(!bt.alive||!state.player.alive){state.gameOver=true;showGameOver(false);return true;}
  if(!rt.alive||!state.enemy.alive){state.gameOver=true;showGameOver(true);return true;}
  return false;
}

// ============ RENDER ============
function render() { renderMap(); renderStats(); renderActions(); renderLog(); }

function renderMap() {
  const mapEl = document.getElementById('map');
  // Build unit lookup: key "x,y" -> array of units
  const units = {};
  const addUnit = (x,y,icon,sub,hp,maxHp) => {
    const k=x+','+y;
    if(!units[k])units[k]=[];
    units[k].push({icon,sub,hp,maxHp});
  };
  for(const tw of state.towers) if(tw.alive) addUnit(tw.x,tw.y, tw.team==='blue'?'ğŸ°':'ğŸ°', tw.team==='blue'?'ğŸ”µ':'ğŸ”´', tw.hp, tw.maxHp);
  for(const m of state.minions) if(m.alive) addUnit(m.x,m.y, m.team==='blue'?'ğŸ‘¤':'ğŸ‘¤', m.team==='blue'?'ğŸ”µ':'ğŸ”´', m.hp, m.maxHp);
  for(const t of state.tibbersList) if(t.alive) addUnit(t.x,t.y,'ğŸ§¸',t.team==='blue'?'ğŸ”µ':'ğŸ”´',t.hp,t.maxHp);
  if(state.player.alive) addUnit(state.player.x,state.player.y,'ğŸ˜ˆ','ğŸ”µ',state.player.hp,state.player.maxHp);
  if(state.enemy.alive) addUnit(state.enemy.x,state.enemy.y,'ğŸ˜ˆ','ğŸ”´',state.enemy.hp,state.enemy.maxHp);

  // Moveable cells for move mode
  const moveCells = new Set();
  if(state.moveMode) {
    const dirs = [[0,-1],[0,1],[-1,0],[1,0]];
    for(const [dx,dy] of dirs) {
      const nx=state.player.x+dx, ny=state.player.y+dy;
      if(isWalkable(nx,ny)) {
        let blocked=false;
        for(const tw of state.towers) if(tw.alive&&tw.x===nx&&tw.y===ny) blocked=true;
        if(!blocked) moveCells.add(nx+','+ny);
      }
    }
  }

  let html='<table>';
  for(let y=0;y<ROWS;y++){
    html+='<tr>';
    for(let x=0;x<COLS;x++){
      const tile=MAP_TEMPLATE[y][x];
      let cls = tile===0?'wall':tile===2?'grass':'lane';
      // Tower cells
      for(const tw of state.towers) if(tw.alive&&tw.x===x&&tw.y===y) cls = tw.team==='blue'?'tower-blue':'tower-red';

      const k=x+','+y;
      const isMove = moveCells.has(k);
      if(isMove) cls+=' highlight';

      let content = '';
      if(units[k]) {
        // Show first unit (stack if multiple)
        const u = units[k];
        if(u.length===1) {
          content = `<span class="unit">${u[0].icon}</span><span class="sub">${u[0].sub}</span>`;
        } else {
          content = `<span class="unit">${u.map(a=>a.icon).join('')}</span><span class="sub">${u.map(a=>a.sub).join('')}</span>`;
        }
      }

      const onclick = isMove ? `onclick="playerMove(${x-state.player.x},${y-state.player.y})"` : '';
      html+=`<td class="${cls}" ${onclick}>${content}</td>`;
    }
    html+='</tr>';
  }
  html+='</table>';
  mapEl.innerHTML = html;
}

function renderStats() {
  const renderPanel = (champ, label, id) => {
    const hpPct=Math.max(0,(champ.hp/champ.maxHp)*100);
    const mpPct=Math.max(0,(champ.mp/champ.maxMp)*100);
    const needed=ANNIE.skills.passive.stacksNeeded;
    let stacks='';
    for(let i=0;i<needed;i++){const c=i<champ.passiveStacks?(champ.passiveStacks>=needed-1?'stack ready':'stack filled'):'stack';stacks+=`<span class="${c}"></span>`;}
    const xpNeeded = champ.level<MAX_LEVEL ? XP_PER_LEVEL[champ.level] : 0;
    const xpPct = xpNeeded>0 ? Math.floor((champ.xp/xpNeeded)*100) : 100;
    const badges=['q','w','e','r'].map(k=>{const s=ANNIE.skills[k];const sl=champ.skillLevels[k];const cd=champ.cooldowns[k];if(sl<=0)return`<span class="skill-badge on-cd">${s.key}(-)</span>`;if(cd>0)return`<span class="skill-badge on-cd">${s.key}${sl}(${cd})</span>`;if(champ.mp<s.manaCost)return`<span class="skill-badge on-cd">${s.key}${sl}</span>`;return`<span class="skill-badge ready">${s.key}${sl}</span>`;}).join('');
    document.getElementById(id).innerHTML=`
      <h3>${label} <span style="color:#f0c040;font-size:11px">Lv.${champ.level}</span></h3>
      <div class="bar-container bar-hp"><div class="bar-fill" style="width:${hpPct}%"></div><div class="bar-label">â¤ï¸ ${champ.hp}/${champ.maxHp}${champ.shield>0?' ğŸ›¡ï¸'+champ.shield:''}</div></div>
      <div class="bar-container bar-mp"><div class="bar-fill" style="width:${mpPct}%"></div><div class="bar-label">ğŸ’§ ${champ.mp}/${champ.maxMp}</div></div>
      <div class="bar-container" style="height:10px;margin-bottom:4px"><div class="bar-fill" style="width:${xpPct}%;background:linear-gradient(90deg,#8844aa,#cc66ff)"></div><div class="bar-label" style="font-size:8px">â­ ${champ.level<MAX_LEVEL?champ.xp+'/'+xpNeeded:'MAX'}</div></div>
      <div class="passive-bar">ğŸ”¥ ${stacks}</div>
      <div class="skill-row">${badges}</div>
      ${champ.stunned?'<div style="color:#ff44ff;margin-top:3px;font-size:11px">âš¡ ìŠ¤í„´!</div>':''}
    `;
  };
  renderPanel(state.player,'ğŸ”µ Annie (ë‚˜)','player-stats');
  renderPanel(state.enemy,'ğŸ”´ Annie (AI)','enemy-stats');

  // Skill level-up buttons for player
  const p = state.player;
  if (p.skillPoints > 0 && p.alive) {
    let lvlHtml = `<div class="skill-lvlup"><span style="font-size:10px;color:#f0c040;margin-right:4px">â¬†ï¸ ìŠ¤í‚¬ í¬ì¸íŠ¸: ${p.skillPoints}</span>`;
    for (const k of ['q','w','e','r']) {
      if (canLevelSkill(p, k)) {
        lvlHtml += `<button onclick="levelUpSkill(state.player,'${k}')">${ANNIE.skills[k].key}â†‘</button>`;
      }
    }
    lvlHtml += '</div>';
    document.getElementById('player-stats').innerHTML += lvlHtml;
  }
}

function renderActions() {
  const el=document.getElementById('actions');
  const p=state.player;
  if(state.gameOver||!p.alive){el.innerHTML='';return;}
  if(state.phase==='target'){el.innerHTML='<em>íƒ€ê²Ÿì„ ì„ íƒí•˜ì„¸ìš”...</em>';return;}
  if(p.stunned){el.innerHTML='<button onclick="endPlayerTurn()">âš¡ ìŠ¤í„´! (í„´ ë„˜ê¸°ê¸°)</button>';return;}

  if(state.moveMode) {
    el.innerHTML='<button class="move" onclick="cancelMoveMode()">âŒ ì´ë™ ì·¨ì†Œ</button>';
    return;
  }

  const can=k=>p.skillLevels[k]>0&&p.cooldowns[k]===0&&p.mp>=ANNIE.skills[k].manaCost;
  el.innerHTML=`
    <button class="move" onclick="enterMoveMode()">ğŸš¶ ì´ë™</button>
    <button class="attack" onclick="playerAA()">âš”ï¸ í‰íƒ€</button>
    <button class="skill-q" onclick="playerSkill('q')" ${!can('q')?'disabled':''}>Q ë¶•ê´´</button>
    <button class="skill-w" onclick="playerSkill('w')" ${!can('w')?'disabled':''}>W ì†Œê°</button>
    <button class="skill-e" onclick="playerSkill('e')" ${!can('e')?'disabled':''}>E ë³´í˜¸ë§‰</button>
    <button class="skill-r" onclick="playerSkill('r')" ${!can('r')?'disabled':''}>ğŸ”¥ R í‹°ë²„</button>
  `;
}

function renderLog() {
  const el=document.getElementById('log');
  const recent=state.logs.slice(-50);
  el.innerHTML=recent.map(l=>`<div class="${l.cls}">${l.msg}</div>`).join('');
  el.scrollTop=el.scrollHeight;
}

initGame();
</script>
</body>
</html>
