<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ib-lol</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a1a; color: #e0e0e0; font-family: 'Courier New', monospace; font-size: 14px; overflow-x: hidden; }
#game { max-width: 900px; margin: 0 auto; padding: 20px; position: relative; }
h1 { text-align: center; color: #f0c040; margin-bottom: 4px; font-size: 24px; }
.subtitle { text-align: center; color: #888; margin-bottom: 20px; font-size: 12px; }

/* Lane display */
#lane-display { background: #111; border: 1px solid #333; padding: 15px; margin-bottom: 15px; border-radius: 4px; white-space: pre; line-height: 1.6; font-size: 13px; overflow-x: auto; }

/* Stats - simplified */
.stats-row { display: flex; gap: 10px; margin-bottom: 15px; }
.stat-panel { flex: 1; background: #111; border: 1px solid #333; padding: 12px; border-radius: 4px; }
.stat-panel.player { border-color: #4488ff; }
.stat-panel.enemy { border-color: #ff4444; }
.stat-panel h3 { margin-bottom: 8px; font-size: 14px; }
.bar-container { background: #222; border-radius: 3px; height: 20px; position: relative; margin-bottom: 6px; overflow: hidden; }
.bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s ease; }
.bar-hp .bar-fill { background: linear-gradient(90deg, #22aa22, #44ff44); }
.bar-mp .bar-fill { background: linear-gradient(90deg, #2244aa, #4488ff); }
.bar-label { position: absolute; top: 0; left: 0; right: 0; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 11px; color: #fff; text-shadow: 1px 1px 2px #000; }
.passive-bar { font-size: 12px; margin-top: 4px; }
.passive-bar .stack { display: inline-block; width: 14px; height: 14px; border: 1px solid #666; border-radius: 2px; margin-right: 2px; }
.passive-bar .stack.filled { background: #ff6600; border-color: #ff8800; }
.passive-bar .stack.ready { background: #ff00ff; border-color: #ff44ff; animation: pulse 0.5s infinite alternate; }
.skill-row { display: flex; gap: 6px; margin-top: 6px; }
.skill-badge { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: #1a1a1a; border: 1px solid #444; }
.skill-badge.on-cd { opacity: 0.35; }
.skill-badge.ready { border-color: #44ff44; color: #44ff44; }

/* Log */
#log { background: #0a0a0a; border: 1px solid #333; padding: 10px; height: 180px; overflow-y: auto; margin-bottom: 15px; border-radius: 4px; font-size: 12px; line-height: 1.6; }
.log-turn { color: #f0c040; font-weight: bold; }
.log-dmg { color: #ff6644; }
.log-heal { color: #44ff44; }
.log-info { color: #88aaff; }
.log-kill { color: #ff44ff; }
.log-ult { color: #ff00ff; font-weight: bold; font-size: 13px; }

/* Actions */
#actions { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
#actions button { background: #222; color: #e0e0e0; border: 1px solid #555; padding: 8px 16px; cursor: pointer; border-radius: 4px; font-family: inherit; font-size: 13px; transition: all 0.15s; }
#actions button:hover:not(:disabled) { background: #333; border-color: #aaa; transform: scale(1.03); }
#actions button:disabled { opacity: 0.3; cursor: not-allowed; }
#actions button.move { border-color: #44aa44; }
#actions button.attack { border-color: #ff6644; }
#actions button.skill-q { border-color: #ff8800; }
#actions button.skill-w { border-color: #ff4444; }
#actions button.skill-e { border-color: #44aaff; }
#actions button.skill-r { border-color: #ff00ff; background: #1a0020; }
#actions button.skill-r:hover:not(:disabled) { background: #2a0040; border-color: #ff44ff; box-shadow: 0 0 12px #ff00ff55; }

/* Target selection */
#target-select { background: #1a1a0a; border: 1px solid #f0c040; padding: 10px; margin-bottom: 15px; border-radius: 4px; display: none; }
#target-select h4 { color: #f0c040; margin-bottom: 8px; }
#target-select button { background: #222; color: #e0e0e0; border: 1px solid #555; padding: 6px 12px; margin: 3px; cursor: pointer; border-radius: 4px; font-family: inherit; font-size: 12px; }
#target-select button:hover { background: #333; }

/* ====== SCREEN EFFECTS ====== */

/* Ult flash overlay */
#ult-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 100; opacity: 0; transition: opacity 0.15s; }
#ult-overlay.flash { opacity: 1; }

/* Screen shake */
@keyframes shake {
  0%,100% { transform: translate(0,0); }
  10% { transform: translate(-8px, 4px); }
  20% { transform: translate(6px, -6px); }
  30% { transform: translate(-4px, 2px); }
  40% { transform: translate(4px, -4px); }
  50% { transform: translate(-2px, 6px); }
  60% { transform: translate(6px, -2px); }
  70% { transform: translate(-6px, 4px); }
  80% { transform: translate(2px, -4px); }
  90% { transform: translate(-4px, 2px); }
}
.screen-shake { animation: shake 0.5s ease; }

/* Pulse animation */
@keyframes pulse { from { opacity: 0.6; } to { opacity: 1; } }

/* ====== GAME OVER OVERLAY ====== */
#game-over-overlay {
  display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
  z-index: 200; justify-content: center; align-items: center; flex-direction: column;
}
#game-over-overlay.show { display: flex; }
#game-over-overlay.victory { background: radial-gradient(ellipse at center, rgba(255,200,0,0.3) 0%, rgba(0,0,0,0.9) 70%); }
#game-over-overlay.defeat { background: radial-gradient(ellipse at center, rgba(255,0,0,0.2) 0%, rgba(0,0,0,0.95) 70%); }

#game-over-text {
  font-size: 60px; font-weight: bold; text-transform: uppercase;
  letter-spacing: 8px; margin-bottom: 20px;
  animation: resultAppear 0.8s ease-out;
}
#game-over-overlay.victory #game-over-text {
  color: #f0c040;
  text-shadow: 0 0 30px #f0c040, 0 0 60px #ff8800, 0 0 100px #f0c04088;
}
#game-over-overlay.defeat #game-over-text {
  color: #ff2222;
  text-shadow: 0 0 30px #ff0000, 0 0 60px #880000;
}
#game-over-sub { font-size: 16px; color: #aaa; margin-bottom: 30px; animation: resultAppear 1s ease-out; }
#game-over-overlay button {
  background: none; border: 2px solid #888; color: #e0e0e0; padding: 12px 40px;
  font-size: 18px; cursor: pointer; border-radius: 4px; font-family: inherit;
  transition: all 0.2s; animation: resultAppear 1.2s ease-out;
}
#game-over-overlay button:hover { border-color: #f0c040; color: #f0c040; }

@keyframes resultAppear {
  0% { opacity: 0; transform: scale(0.5) translateY(20px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}

/* Floating damage numbers */
.float-text {
  position: fixed; pointer-events: none; z-index: 50;
  font-weight: bold; font-family: 'Courier New', monospace;
  animation: floatUp 1s ease-out forwards;
}
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
}

/* Particles for ult */
.particle {
  position: fixed; pointer-events: none; z-index: 90;
  border-radius: 50%; animation: particleFly 1s ease-out forwards;
}
@keyframes particleFly {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(0) translateY(-100px); }
}
</style>
</head>
<body>
<div id="game">
  <h1>‚öîÔ∏è ib-lol ‚öîÔ∏è</h1>
  <div class="subtitle">ÌÑ¥Ï†ú 1v1 ÎùºÏù∏Ï†Ñ ‚Äî Annie Mirror Match</div>
  <div id="lane-display"></div>
  <div class="stats-row">
    <div class="stat-panel player" id="player-stats"></div>
    <div class="stat-panel enemy" id="enemy-stats"></div>
  </div>
  <div id="target-select"><h4>üéØ ÌÉÄÍ≤ü ÏÑ†ÌÉù</h4><div id="target-buttons"></div></div>
  <div id="actions"></div>
  <div id="log"></div>
</div>
<div id="ult-overlay"></div>
<div id="game-over-overlay">
  <div id="game-over-text"></div>
  <div id="game-over-sub"></div>
  <button onclick="restartGame()">Îã§Ïãú ÌïòÍ∏∞</button>
</div>
<script>
// ============ CONFIG ============
const LANE_SIZE = 13;
const TOWER_HP = 1500, TOWER_DMG = 80, TOWER_RANGE = 2;
const MINION_HP = 300, MINION_DMG = 15, MINION_GOLD = 20, MINION_SPAWN_INTERVAL = 3;

const ANNIE = {
  name: 'Annie', hp: 560, mp: 418, ad: 50, ap: 0, armor: 19, mr: 30,
  skills: {
    passive: { name: 'ÌååÏù¥Î°úÎß§ÎãàÏïÑ', stacksNeeded: 4 },
    q: { name: 'Î∂ïÍ¥¥', key: 'Q', damage: 80, manaCost: 60, cooldown: 0, range: 3, type: 'target' },
    w: { name: 'ÏÜåÍ∞Å', key: 'W', damage: 70, manaCost: 70, cooldown: 1, range: 2, type: 'direction' },
    e: { name: 'Î≥¥Ìò∏Îßâ', key: 'E', shield: 40, shieldApRatio: 0.4, manaCost: 40, cooldown: 3, type: 'self' },
    r: { name: 'Ìã∞Î≤Ñ', key: 'R', damage: 150, manaCost: 100, cooldown: 8, range: 3, type: 'target', summon: true }
  }
};

// ============ STATE ============
let state;

function createChampion(t, team, pos) {
  return { type:'champion', team, name:t.name, pos, maxHp:t.hp, hp:t.hp, maxMp:t.mp, mp:t.mp, ad:t.ad, ap:t.ap, armor:t.armor, mr:t.mr, passiveStacks:0, shield:0, cooldowns:{q:0,w:0,e:0,r:0}, tibbers:null, gold:0, alive:true, stunned:false };
}
function createTower(team, pos) { return { type:'tower', team, pos, hp:TOWER_HP, maxHp:TOWER_HP, alive:true, ad:TOWER_DMG, range:TOWER_RANGE, armor:0, mr:0 }; }
function createMinion(team, pos, id) { return { type:'minion', team, pos, hp:MINION_HP, maxHp:MINION_HP, ad:MINION_DMG, alive:true, id, armor:0, mr:0 }; }

function initGame() {
  state = { turn:1, player:createChampion(ANNIE,'blue',2), enemy:createChampion(ANNIE,'red',10), towers:[createTower('blue',0),createTower('red',12)], minions:[], tibbersList:[], minionIdCounter:0, logs:[], phase:'action', gameOver:false };
  spawnMinions();
  render();
}
function restartGame() {
  document.getElementById('game-over-overlay').classList.remove('show','victory','defeat');
  initGame();
}

function log(msg, cls='') { state.logs.push({msg,cls}); }
function dist(a,b) { return Math.abs(a-b); }
function calcDmg(raw, type, target) {
  const def = type==='magic' ? (target.mr||0) : (target.armor||0);
  return Math.max(1, Math.floor(raw * (100/(100+def))));
}
function applyDmg(target, amount) {
  if (target.shield > 0) { if (target.shield >= amount) { target.shield -= amount; return 0; } amount -= target.shield; target.shield = 0; }
  target.hp = Math.max(0, target.hp - amount);
  if (target.hp <= 0) target.alive = false;
  return amount;
}

function spawnMinions() {
  if (state.turn % MINION_SPAWN_INTERVAL === 1 || state.turn === 1) {
    state.minionIdCounter++;
    state.minions.push(createMinion('blue',1,'B'+state.minionIdCounter));
    state.minionIdCounter++;
    state.minions.push(createMinion('red',11,'R'+state.minionIdCounter));
    log('üè∞ ÎØ∏ÎãàÏñ∏ ÏÉùÏÑ±!','log-info');
  }
}

// ============ EFFECTS ============
function screenShake() {
  document.getElementById('game').classList.add('screen-shake');
  setTimeout(() => document.getElementById('game').classList.remove('screen-shake'), 500);
}

function ultFlash(color) {
  const ov = document.getElementById('ult-overlay');
  ov.style.background = color;
  ov.classList.add('flash');
  screenShake();
  setTimeout(() => ov.classList.remove('flash'), 200);
}

function spawnParticles(count, color) {
  for (let i = 0; i < count; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    const size = 4 + Math.random() * 8;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    p.style.background = color;
    p.style.boxShadow = `0 0 ${size}px ${color}`;
    p.style.left = (20 + Math.random() * 60) + 'vw';
    p.style.top = (20 + Math.random() * 60) + 'vh';
    p.style.animationDuration = (0.5 + Math.random() * 1) + 's';
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 1500);
  }
}

function floatText(text, color, x, y) {
  const el = document.createElement('div');
  el.className = 'float-text';
  el.textContent = text;
  el.style.color = color;
  el.style.fontSize = (16 + Math.random() * 8) + 'px';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

function showGameOver(victory) {
  const overlay = document.getElementById('game-over-overlay');
  const text = document.getElementById('game-over-text');
  const sub = document.getElementById('game-over-sub');

  if (victory) {
    overlay.classList.add('show','victory');
    text.textContent = 'VICTORY';
    const rt = state.towers.find(t=>t.team==='red');
    sub.textContent = !state.enemy.alive ? 'Ï†Å Ï±îÌîºÏñ∏ÏùÑ Ï≤òÏπòÌñàÏäµÎãàÎã§!' : 'Ï†Å ÌÉÄÏõåÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§!';
    spawnParticles(40, '#f0c040');
    setTimeout(() => spawnParticles(30, '#ff8800'), 300);
    setTimeout(() => spawnParticles(20, '#ffee88'), 600);
  } else {
    overlay.classList.add('show','defeat');
    text.textContent = 'DEFEAT';
    const bt = state.towers.find(t=>t.team==='blue');
    sub.textContent = !state.player.alive ? 'Ï±îÌîºÏñ∏Ïù¥ Ïì∞Îü¨Ï°åÏäµÎãàÎã§...' : 'ÏïÑÍµ∞ ÌÉÄÏõåÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§...';
    screenShake();
    setTimeout(() => screenShake(), 300);
  }
}

// ============ SKILLS ============
function executeSkill(caster, key, target) {
  const skill = ANNIE.skills[key];
  if (caster.cooldowns[key] > 0 || caster.mp < skill.manaCost) return false;
  caster.mp -= skill.manaCost;
  caster.cooldowns[key] = skill.cooldown;

  caster.passiveStacks++;
  let willStun = false;
  if (caster.passiveStacks >= ANNIE.skills.passive.stacksNeeded) { willStun = true; caster.passiveStacks = 0; }

  const cl = caster.team==='blue'?'üîµ':'üî¥';

  if (key === 'e') {
    const s = Math.floor(skill.shield + skill.shieldApRatio * caster.ap);
    caster.shield += s;
    log(`${cl} ${caster.name} E Î≥¥Ìò∏Îßâ +${s}`, 'log-info');
    return true;
  }

  if (!target || !target.alive || dist(caster.pos, target.pos) > skill.range) return false;

  const raw = skill.damage + caster.ap;
  const dmg = calcDmg(raw, 'magic', target);
  applyDmg(target, dmg);

  const tl = target.team==='blue'?'üîµ':'üî¥';

  // ULT EFFECT
  if (key === 'r') {
    const color = caster.team === 'blue' ? 'rgba(100,0,255,0.4)' : 'rgba(255,0,100,0.4)';
    ultFlash(color);
    spawnParticles(25, caster.team==='blue' ? '#8844ff' : '#ff4488');
    log(`üî•üß∏ ${cl} ${caster.name} ‚Äî ÏÜåÌôò: Ìã∞Î≤Ñ!! ‚Üí ${tl}${target.name||target.type}ÏóêÍ≤å ${dmg} ÌîºÌï¥!`, 'log-ult');

    if (!caster.tibbers) {
      const tib = { type:'tibbers', team:caster.team, pos:target.pos, hp:300, maxHp:300, ad:40, alive:true, armor:0, mr:0, owner:caster };
      caster.tibbers = tib;
      state.tibbersList.push(tib);
    }
  } else {
    log(`${cl} ${caster.name} ${skill.key}(${skill.name}) ‚Üí ${tl}${target.name||target.type}ÏóêÍ≤å ${dmg}`, 'log-dmg');
  }

  if (willStun && target.type === 'champion') {
    target.stunned = true;
    log(`‚ö° ÌååÏù¥Î°úÎß§ÎãàÏïÑ! ${tl}${target.name} Ïä§ÌÑ¥!`, 'log-kill');
  }

  if (key === 'q' && !target.alive) {
    caster.mp = Math.min(caster.maxMp, caster.mp + skill.manaCost);
    log(`üí∞ Q Ï≤òÏπò ÎßàÎÇò ÌöåÎ≥µ!`, 'log-heal');
  }

  if (!target.alive) handleKill(caster, target);
  return true;
}

function handleKill(killer, victim) {
  const kl = killer.team==='blue'?'üîµ':'üî¥';
  if (victim.type==='minion') { killer.gold += MINION_GOLD; log(`${kl} ÎØ∏ÎãàÏñ∏ Ï≤òÏπò +${MINION_GOLD}G`,'log-kill'); }
  else if (victim.type==='champion') { killer.gold += 300; log(`${kl} Ï±îÌîºÏñ∏ Ï≤òÏπò! +300G`,'log-kill'); }
}

function autoAttack(atk, tgt) {
  if (!tgt?.alive || dist(atk.pos, tgt.pos) > 2) return false;
  const dmg = calcDmg(atk.ad, 'physical', tgt);
  applyDmg(tgt, dmg);
  const al = atk.team==='blue'?'üîµ':'üî¥', tl = tgt.team==='blue'?'üîµ':'üî¥';
  log(`${al} ${atk.name||atk.type} ‚Üí ${tl}${tgt.name||tgt.type} ${dmg}`, 'log-dmg');
  if (!tgt.alive) handleKill(atk, tgt);
  return true;
}

function getEnemyTargets(unit) {
  const et = unit.team==='blue'?'red':'blue';
  let t = [];
  const ec = unit.team==='blue'?state.enemy:state.player;
  if (ec.alive) t.push(ec);
  state.minions.filter(m=>m.alive&&m.team===et).forEach(m=>t.push(m));
  state.towers.filter(tw=>tw.alive&&tw.team===et).forEach(tw=>t.push(tw));
  state.tibbersList.filter(tb=>tb.alive&&tb.team===et).forEach(tb=>t.push(tb));
  return t;
}
function getInRange(unit, range) { return getEnemyTargets(unit).filter(t=>dist(unit.pos,t.pos)<=range); }
function targetLabel(t) {
  if (t.type==='champion') return `${t.name} (${t.hp}HP)`;
  if (t.type==='minion') return `ÎØ∏ÎãàÏñ∏ (${t.hp}HP)`;
  if (t.type==='tower') return `ÌÉÄÏõå (${t.hp}HP)`;
  if (t.type==='tibbers') return `Ìã∞Î≤Ñ (${t.hp}HP)`;
  return t.type;
}

// ============ PLAYER ACTIONS ============
function playerMove(dir) {
  const np = state.player.pos+dir;
  if (np<0||np>=LANE_SIZE) return;
  state.player.pos = np;
  log(`üîµ Ïù¥Îèô ‚Üí ${np}`,'log-info');
  endPlayerTurn();
}
function playerAA() {
  const ts = getInRange(state.player, 2);
  if (!ts.length) { log('‚ö†Ô∏è ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÎåÄÏÉÅ ÏóÜÏùå','log-info'); render(); return; }
  if (ts.length===1) { autoAttack(state.player, ts[0]); endPlayerTurn(); }
  else showTargetSelect(ts, t=>{ autoAttack(state.player,t); endPlayerTurn(); });
}
function playerSkill(key) {
  const p = state.player, s = ANNIE.skills[key];
  if (p.cooldowns[key]>0) return;
  if (p.mp<s.manaCost) { log('‚ö†Ô∏è ÎßàÎÇò Î∂ÄÏ°±!','log-info'); render(); return; }
  if (s.type==='self') { executeSkill(p,key,null); endPlayerTurn(); }
  else {
    const ts = getInRange(p, s.range);
    if (!ts.length) { log('‚ö†Ô∏è ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÎåÄÏÉÅ ÏóÜÏùå','log-info'); render(); return; }
    if (ts.length===1) { executeSkill(p,key,ts[0]); endPlayerTurn(); }
    else showTargetSelect(ts, t=>{ executeSkill(p,key,t); endPlayerTurn(); });
  }
}

function showTargetSelect(targets, cb) {
  state.phase = 'target';
  const c = document.getElementById('target-buttons'); c.innerHTML = '';
  const div = document.getElementById('target-select'); div.style.display = 'block';
  targets.forEach(t => {
    const b = document.createElement('button'); b.textContent = targetLabel(t);
    b.onclick = () => { div.style.display='none'; state.phase='action'; cb(t); };
    c.appendChild(b);
  });
  const cancel = document.createElement('button'); cancel.textContent = 'Ï∑®ÏÜå'; cancel.style.borderColor='#ff4444';
  cancel.onclick = () => { div.style.display='none'; state.phase='action'; render(); };
  c.appendChild(cancel);
  render();
}

// ============ TURN FLOW ============
function endPlayerTurn() {
  document.getElementById('target-select').style.display = 'none';
  if (checkGameOver()) { render(); return; }
  aiTurn(); if (checkGameOver()) { render(); return; }
  minionTurns(); if (checkGameOver()) { render(); return; }
  towerAttacks(); if (checkGameOver()) { render(); return; }
  tibbersAI(); if (checkGameOver()) { render(); return; }

  for (let k of ['q','w','e','r']) { if(state.player.cooldowns[k]>0)state.player.cooldowns[k]--; if(state.enemy.cooldowns[k]>0)state.enemy.cooldowns[k]--; }
  state.player.stunned = false; state.enemy.stunned = false;
  state.player.mp = Math.min(state.player.maxMp, state.player.mp+10);
  state.enemy.mp = Math.min(state.enemy.maxMp, state.enemy.mp+10);

  state.turn++;
  spawnMinions();
  state.minions = state.minions.filter(m=>m.alive);
  state.tibbersList = state.tibbersList.filter(t=>t.alive);
  if (state.player.tibbers&&!state.player.tibbers.alive) state.player.tibbers=null;
  if (state.enemy.tibbers&&!state.enemy.tibbers.alive) state.enemy.tibbers=null;

  log(`‚îÅ‚îÅ‚îÅ ÌÑ¥ ${state.turn} ‚îÅ‚îÅ‚îÅ`,'log-turn');
  render();
}

// ============ AI ============
function aiTurn() {
  const ai = state.enemy;
  if (!ai.alive) return;
  if (ai.stunned) { log('üî¥ Ïä§ÌÑ¥! ÌÑ¥ Ïä§ÌÇµ','log-info'); return; }
  const p = state.player;

  if (ai.cooldowns.r===0 && ai.mp>=ANNIE.skills.r.manaCost && p.alive && dist(ai.pos,p.pos)<=ANNIE.skills.r.range) { executeSkill(ai,'r',p); return; }
  if (ai.cooldowns.q===0 && ai.mp>=ANNIE.skills.q.manaCost) {
    const ms = state.minions.filter(m=>m.alive&&m.team==='blue'&&dist(ai.pos,m.pos)<=3);
    const lh = ms.find(m=>m.hp<=80);
    if (lh) { executeSkill(ai,'q',lh); return; }
    if (p.alive && dist(ai.pos,p.pos)<=3) { executeSkill(ai,'q',p); return; }
  }
  if (ai.cooldowns.w===0 && ai.mp>=ANNIE.skills.w.manaCost) { const ts=getInRange(ai,2); if(ts.length) { executeSkill(ai,'w',ts[0]); return; } }
  if (ai.cooldowns.e===0 && ai.shield===0 && ai.mp>=ANNIE.skills.e.manaCost) { executeSkill(ai,'e',null); return; }

  const aa = getInRange(ai, 2);
  if (aa.length) { const lm=aa.find(t=>t.type==='minion'&&t.hp<=ai.ad); autoAttack(ai, lm||aa.find(t=>t.type==='champion')||aa[0]); return; }
  if (ai.pos > 6) { ai.pos--; log(`üî¥ Ïù¥Îèô ‚Üí ${ai.pos}`,'log-info'); }
}

function minionTurns() {
  for (const m of state.minions) {
    if (!m.alive) continue;
    const et = m.team==='blue'?'red':'blue';
    const enemies = [...state.minions.filter(e=>e.alive&&e.team===et)];
    const ec = m.team==='blue'?state.enemy:state.player;
    if (ec.alive) enemies.push(ec);
    state.towers.filter(t=>t.alive&&t.team===et).forEach(t=>enemies.push(t));
    let closest=null, cd=999;
    for (const e of enemies) { const d=dist(m.pos,e.pos); if(d<cd){cd=d;closest=e;} }
    if (closest&&cd<=1) { const dmg=calcDmg(m.ad,'physical',closest); applyDmg(closest,dmg); if(!closest.alive&&closest.type==='champion') log('üíÄ ÎØ∏ÎãàÏñ∏Ïù¥ Ï±îÌîºÏñ∏ Ï≤òÏπò!','log-kill'); }
    else { const d=m.team==='blue'?1:-1; const np=m.pos+d; if(np>=0&&np<LANE_SIZE) m.pos=np; }
  }
}

function towerAttacks() {
  for (const tw of state.towers) {
    if (!tw.alive) continue;
    const et = tw.team==='blue'?'red':'blue';
    const ir = [];
    state.minions.filter(m=>m.alive&&m.team===et&&dist(tw.pos,m.pos)<=tw.range).forEach(m=>ir.push(m));
    const ec = tw.team==='blue'?state.enemy:state.player;
    if (ec.alive&&dist(tw.pos,ec.pos)<=tw.range) ir.push(ec);
    state.tibbersList.filter(t=>t.alive&&t.team===et&&dist(tw.pos,t.pos)<=tw.range).forEach(t=>ir.push(t));
    if (ir.length) {
      const tgt = ir.find(t=>t.type==='minion')||ir[0];
      const dmg = calcDmg(tw.ad,'physical',tgt);
      applyDmg(tgt, dmg);
      const tl = tw.team==='blue'?'üîµ':'üî¥';
      log(`üè∞${tl} ÌÉÄÏõå ‚Üí ${tgt.name||tgt.type} ${dmg}`,'log-dmg');
    }
  }
}

function tibbersAI() {
  for (const tib of state.tibbersList) {
    if (!tib.alive) continue;
    const enemies = getEnemyTargets(tib);
    let closest=null, cd=999;
    for (const e of enemies) { const d=dist(tib.pos,e.pos); if(d<cd){cd=d;closest=e;} }
    if (closest&&cd<=1) { const dmg=calcDmg(tib.ad,'physical',closest); applyDmg(closest,dmg); log(`üß∏ Ìã∞Î≤Ñ ‚Üí ${closest.name||closest.type} ${dmg}`,'log-dmg'); }
    else if (closest) { tib.pos += tib.pos<closest.pos?1:-1; }
  }
}

// ============ GAME OVER ============
function checkGameOver() {
  const bt = state.towers.find(t=>t.team==='blue'), rt = state.towers.find(t=>t.team==='red');
  if (!bt.alive || !state.player.alive) { state.gameOver=true; showGameOver(false); return true; }
  if (!rt.alive || !state.enemy.alive) { state.gameOver=true; showGameOver(true); return true; }
  return false;
}

// ============ RENDER ============
function render() { renderLane(); renderStats(); renderActions(); renderLog(); }

function renderLane() {
  const el = document.getElementById('lane-display');
  let lane = []; for(let i=0;i<LANE_SIZE;i++) lane[i]=[];
  for (const t of state.towers) if(t.alive) lane[t.pos].push(t.team==='blue'?'üè∞üîµ':'üè∞üî¥');
  for (const m of state.minions) if(m.alive) lane[m.pos].push(m.team==='blue'?'üë§üîµ':'üë§üî¥');
  for (const t of state.tibbersList) if(t.alive) lane[t.pos].push(t.team==='blue'?'üß∏üîµ':'üß∏üî¥');
  if (state.player.alive) lane[state.player.pos].push('üîµAnnie');
  if (state.enemy.alive) lane[state.enemy.pos].push('üî¥Annie');

  let header='  ', units='  ';
  for(let i=0;i<LANE_SIZE;i++) header += String(i).padStart(2,' ').padEnd(8);
  for(let i=0;i<LANE_SIZE;i++) { const c=lane[i].length?lane[i].join(' '):'¬∑'; units+=c.padEnd(6)+'  '; }
  el.textContent = `ÌÑ¥ ${state.turn}\n${header}\n${units}`;
}

function renderStats() {
  const renderPanel = (champ, label, id) => {
    const hpPct = Math.max(0, (champ.hp/champ.maxHp)*100);
    const mpPct = Math.max(0, (champ.mp/champ.maxMp)*100);
    const needed = ANNIE.skills.passive.stacksNeeded;
    let stacks = '';
    for (let i=0;i<needed;i++) {
      const cls = i<champ.passiveStacks ? (champ.passiveStacks>=needed-1?'stack ready':'stack filled') : 'stack';
      stacks += `<span class="${cls}"></span>`;
    }
    const skillBadges = ['q','w','e','r'].map(k => {
      const s = ANNIE.skills[k];
      const cd = champ.cooldowns[k];
      if (cd>0) return `<span class="skill-badge on-cd">${s.key} (${cd})</span>`;
      if (champ.mp<s.manaCost) return `<span class="skill-badge on-cd">${s.key}</span>`;
      return `<span class="skill-badge ready">${s.key}</span>`;
    }).join('');

    document.getElementById(id).innerHTML = `
      <h3>${label}</h3>
      <div class="bar-container bar-hp"><div class="bar-fill" style="width:${hpPct}%"></div><div class="bar-label">‚ù§Ô∏è ${champ.hp} / ${champ.maxHp}${champ.shield>0?' üõ°Ô∏è'+champ.shield:''}</div></div>
      <div class="bar-container bar-mp"><div class="bar-fill" style="width:${mpPct}%"></div><div class="bar-label">üíß ${champ.mp} / ${champ.maxMp}</div></div>
      <div class="passive-bar">üî• ${stacks}</div>
      <div class="skill-row">${skillBadges}</div>
      ${champ.stunned?'<div style="color:#ff44ff;margin-top:4px">‚ö° Ïä§ÌÑ¥!</div>':''}
    `;
  };
  renderPanel(state.player, 'üîµ Annie (ÎÇò)', 'player-stats');
  renderPanel(state.enemy, 'üî¥ Annie (AI)', 'enemy-stats');
}

function renderActions() {
  const el = document.getElementById('actions');
  const p = state.player;
  if (state.gameOver||!p.alive) { el.innerHTML=''; return; }
  if (state.phase==='target') { el.innerHTML='<em>ÌÉÄÍ≤üÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî...</em>'; return; }
  if (p.stunned) { el.innerHTML='<button onclick="endPlayerTurn()">‚ö° Ïä§ÌÑ¥! (ÌÑ¥ ÎÑòÍ∏∞Í∏∞)</button>'; return; }

  const can = k => p.cooldowns[k]===0 && p.mp>=ANNIE.skills[k].manaCost;
  el.innerHTML = `
    <button class="move" onclick="playerMove(-1)" ${p.pos<=0?'disabled':''}>‚Üê Ïù¥Îèô</button>
    <button class="move" onclick="playerMove(1)" ${p.pos>=LANE_SIZE-1?'disabled':''}>Ïù¥Îèô ‚Üí</button>
    <button class="attack" onclick="playerAA()">‚öîÔ∏è ÌèâÌÉÄ</button>
    <button class="skill-q" onclick="playerSkill('q')" ${!can('q')?'disabled':''}>Q Î∂ïÍ¥¥</button>
    <button class="skill-w" onclick="playerSkill('w')" ${!can('w')?'disabled':''}>W ÏÜåÍ∞Å</button>
    <button class="skill-e" onclick="playerSkill('e')" ${!can('e')?'disabled':''}>E Î≥¥Ìò∏Îßâ</button>
    <button class="skill-r" onclick="playerSkill('r')" ${!can('r')?'disabled':''}>üî• R Ìã∞Î≤Ñ</button>
  `;
}

function renderLog() {
  const el = document.getElementById('log');
  const recent = state.logs.slice(-50);
  el.innerHTML = recent.map(l=>`<div class="${l.cls}">${l.msg}</div>`).join('');
  el.scrollTop = el.scrollHeight;
}

initGame();
</script>
</body>
</html>
