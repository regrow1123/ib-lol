<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ib-lol</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#0a0a1a; color:#e0e0e0; font-family:'Courier New',monospace; font-size:14px; overflow-x:hidden; }
#game { max-width:960px; margin:0 auto; padding:16px; position:relative; }
h1 { text-align:center; color:#f0c040; margin-bottom:2px; font-size:22px; }
.subtitle { text-align:center; color:#888; margin-bottom:12px; font-size:11px; }

/* Map */
#map { display:flex; justify-content:center; margin-bottom:12px; }
#map table { border-collapse:collapse; }
#map td {
  width:48px; height:48px; border:1px solid #1a1a1a; text-align:center; vertical-align:middle;
  font-size:16px; background:#0d0d15; cursor:default; transition:background 0.15s; position:relative;
}
#map td.wall { background:#111; }
#map td.walkable { background:#0d0d15; }
#map td.highlight { background:#333300 !important; border-color:#555500; cursor:pointer; }
#map td.target-mode { background:#2a0a0a !important; border-color:#552200; cursor:crosshair; }
#map td.reveal-flash { animation:revealPulse 1s ease-out; }
#map td .unit { display:block; line-height:1.1; font-size:18px; }
#map td .sub { font-size:8px; display:block; color:#aaa; }
#map td .minion-marker { font-size:14px; }
#map td .ghost { opacity:0.35; }

/* Stats */
.stats-row { display:flex; gap:8px; margin-bottom:10px; }
.stat-panel { flex:1; background:#111; border:1px solid #333; padding:10px; border-radius:4px; }
.stat-panel.player { border-color:#4488ff; }
.stat-panel.enemy { border-color:#ff4444; }
.stat-panel h3 { margin-bottom:6px; font-size:13px; }
.bar-container { background:#222; border-radius:3px; height:18px; position:relative; margin-bottom:4px; overflow:hidden; }
.bar-fill { height:100%; border-radius:3px; transition:width 0.3s; }
.bar-hp .bar-fill { background:linear-gradient(90deg,#22aa22,#44ff44); }
.bar-mp .bar-fill { background:linear-gradient(90deg,#2244aa,#4488ff); }
.bar-label { position:absolute; top:0; left:0; right:0; height:100%; display:flex; align-items:center; justify-content:center; font-size:10px; color:#fff; text-shadow:1px 1px 2px #000; }
.passive-bar { font-size:11px; margin-top:3px; }
.passive-bar .stack { display:inline-block; width:12px; height:12px; border:1px solid #666; border-radius:2px; margin-right:2px; }
.passive-bar .stack.filled { background:#ff6600; border-color:#ff8800; }
.passive-bar .stack.ready { background:#ff00ff; border-color:#ff44ff; animation:pulse 0.5s infinite alternate; }
.skill-row { display:flex; gap:4px; margin-top:4px; }
.skill-badge { font-size:10px; padding:2px 5px; border-radius:3px; background:#1a1a1a; border:1px solid #444; }
.skill-badge.on-cd { opacity:0.35; }
.skill-badge.ready { border-color:#44ff44; color:#44ff44; }
.skill-lvlup { display:flex; gap:4px; margin-top:4px; }
.skill-lvlup button { font-size:10px; padding:2px 8px; background:#1a1a00; border:1px solid #f0c040; color:#f0c040; border-radius:3px; cursor:pointer; font-family:inherit; animation:pulse 0.8s infinite alternate; }
.skill-lvlup button:hover { background:#333300; }
.enemy-unknown { color:#666; font-style:italic; font-size:11px; }

/* Turn phase */
#phase-bar { background:#111; border:1px solid #f0c040; padding:10px; margin-bottom:10px; border-radius:4px; text-align:center; }
#phase-bar .phase-title { color:#f0c040; font-size:13px; font-weight:bold; margin-bottom:6px; }
#phase-bar .ai-action { color:#ff6644; font-size:12px; margin-bottom:6px; }
#phase-bar .player-action { color:#88aaff; font-size:12px; margin-bottom:6px; }

/* Actions */
#actions { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:10px; justify-content:center; }
#actions button { background:#222; color:#e0e0e0; border:1px solid #555; padding:7px 14px; cursor:pointer; border-radius:4px; font-family:inherit; font-size:12px; transition:all 0.15s; }
#actions button:hover:not(:disabled) { background:#333; border-color:#aaa; }
#actions button:disabled { opacity:0.3; cursor:not-allowed; }
#actions button.move { border-color:#44aa44; }
#actions button.attack { border-color:#ff6644; }
#actions button.skill-q { border-color:#ff8800; }
#actions button.skill-w { border-color:#ff4444; }
#actions button.skill-e { border-color:#44aaff; }
#actions button.skill-r { border-color:#ff00ff; background:#1a0020; }
#actions button.confirm { border-color:#f0c040; background:#2a2a00; color:#f0c040; font-weight:bold; }
#actions button.confirm:hover { background:#444400; }
#actions button.cancel { border-color:#ff4444; }

/* Shop */
#shop { display:none; background:#111; border:1px solid #f0c040; padding:10px; margin-bottom:10px; border-radius:4px; }
#shop h4 { color:#f0c040; margin-bottom:8px; font-size:13px; }
#shop .shop-grid { display:flex; flex-wrap:wrap; gap:6px; }
#shop .shop-item { background:#1a1a1a; border:1px solid #333; padding:6px 8px; border-radius:4px; cursor:pointer; font-size:11px; font-family:inherit; color:#e0e0e0; transition:all 0.15s; min-width:120px; }
#shop .shop-item:hover { border-color:#f0c040; background:#222; }
#shop .shop-item.cant { opacity:0.35; cursor:not-allowed; }
#shop .shop-item .item-name { color:#f0c040; }
#shop .shop-item .item-cost { color:#ffaa00; }
#shop .shop-item .item-stats { color:#888; font-size:10px; }
.inventory { font-size:10px; margin-top:4px; color:#aaa; }
.inventory span { background:#1a1a1a; border:1px solid #333; padding:1px 4px; border-radius:2px; margin-right:2px; }

/* Log */
#log { background:#0a0a0a; border:1px solid #333; padding:8px; height:180px; overflow-y:auto; margin-bottom:10px; border-radius:4px; font-size:11px; line-height:1.5; }
.log-turn { color:#f0c040; font-weight:bold; }
.log-dmg { color:#ff6644; }
.log-heal { color:#44ff44; }
.log-info { color:#88aaff; }
.log-kill { color:#ff44ff; }
.log-ult { color:#ff00ff; font-weight:bold; }
.log-reveal { color:#ffcc00; font-weight:bold; }
.log-miss { color:#666; }

/* Effects */
#ult-overlay { position:fixed; top:0; left:0; width:100vw; height:100vh; pointer-events:none; z-index:100; opacity:0; transition:opacity 0.15s; }
#ult-overlay.flash { opacity:1; }
@keyframes shake { 0%,100%{transform:translate(0,0)}10%{transform:translate(-6px,3px)}30%{transform:translate(4px,-4px)}50%{transform:translate(-3px,5px)}70%{transform:translate(5px,-2px)}90%{transform:translate(-4px,2px)} }
.screen-shake { animation:shake 0.4s ease; }
@keyframes pulse { from{opacity:0.6}to{opacity:1} }
@keyframes revealPulse { 0%{box-shadow:0 0 20px #ffcc00}100%{box-shadow:none} }

/* Game over */
#game-over-overlay { display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:200; justify-content:center; align-items:center; flex-direction:column; }
#game-over-overlay.show { display:flex; }
#game-over-overlay.victory { background:radial-gradient(ellipse at center,rgba(255,200,0,0.3) 0%,rgba(0,0,0,0.9) 70%); }
#game-over-overlay.defeat { background:radial-gradient(ellipse at center,rgba(255,0,0,0.2) 0%,rgba(0,0,0,0.95) 70%); }
#game-over-text { font-size:56px; font-weight:bold; letter-spacing:8px; margin-bottom:16px; animation:resultAppear 0.8s ease-out; }
#game-over-overlay.victory #game-over-text { color:#f0c040; text-shadow:0 0 30px #f0c040,0 0 60px #ff8800; }
#game-over-overlay.defeat #game-over-text { color:#ff2222; text-shadow:0 0 30px #ff0000,0 0 60px #880000; }
#game-over-sub { font-size:14px; color:#aaa; margin-bottom:24px; animation:resultAppear 1s ease-out; }
#game-over-overlay button { background:none; border:2px solid #888; color:#e0e0e0; padding:10px 36px; font-size:16px; cursor:pointer; border-radius:4px; font-family:inherit; animation:resultAppear 1.2s ease-out; }
#game-over-overlay button:hover { border-color:#f0c040; color:#f0c040; }
@keyframes resultAppear { 0%{opacity:0;transform:scale(0.5) translateY(20px)}100%{opacity:1;transform:scale(1) translateY(0)} }
.particle { position:fixed; pointer-events:none; z-index:90; border-radius:50%; animation:particleFly 1s ease-out forwards; }
@keyframes particleFly { 0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0) translateY(-100px)} }
</style>
</head>
<body>
<div id="game">
  <h1>âš”ï¸ ib-lol âš”ï¸</h1>
  <div class="subtitle">í„´ì œ 1v1 â€” ì•ˆê°œ ì†ì˜ ë¼ì¸ì „</div>
  <div id="map"></div>
  <div class="stats-row">
    <div class="stat-panel player" id="player-stats"></div>
    <div class="stat-panel enemy" id="enemy-stats"></div>
  </div>
  <div id="phase-bar"></div>
  <div id="shop"></div>
  <div id="actions"></div>
  <div id="log"></div>
</div>
<div id="ult-overlay"></div>
<div id="game-over-overlay">
  <div id="game-over-text"></div>
  <div id="game-over-sub"></div>
  <button onclick="restartGame()">ë‹¤ì‹œ í•˜ê¸°</button>
</div>

<script>
// ============ CONFIG ============
const COLS=15, ROWS=7;
const REVEAL_INTERVAL=5;
const MINION_RESPAWN_INTERVAL=10;

// Map: 0=wall, 1=walkable
const MAP=[];
for(let y=0;y<ROWS;y++){MAP[y]=[];for(let x=0;x<COLS;x++){MAP[y][x]=(x===0||x===COLS-1||y===0||y===ROWS-1)?0:1;}}

// Fixed minion positions (symmetrical)
const MINION_POSITIONS=[
  {x:5,y:2},{x:3,y:3},{x:5,y:4},
  {x:7,y:1},{x:7,y:3},{x:7,y:5},
  {x:9,y:2},{x:11,y:3},{x:9,y:4},
];
// Buff monsters (ì¢Œìƒë‹¨, ìš°í•˜ë‹¨)
const BUFF_POSITIONS=[
  {x:3,y:1,type:'red'},    // Red buff - ì¢Œìƒë‹¨
  {x:11,y:5,type:'blue'},  // Blue buff - ìš°í•˜ë‹¨
];
const BUFF_RESPAWN=15;
const BUFF_DURATION=10;
const BUFF_XP=200, BUFF_GOLD=50;

// Epic monsters (ì¢Œí•˜ë‹¨, ìš°ìƒë‹¨)
const EPIC_POSITIONS=[
  {x:3,y:5,type:'dragon'},  // ë“œë˜ê³¤ - ì¢Œí•˜ë‹¨
  {x:11,y:1,type:'baron'},  // ë°”ë¡  - ìš°ìƒë‹¨
];
const EPIC_RESPAWN=20;
const DRAGON_HP=5, BARON_HP=8;
const DRAGON_XP=400, DRAGON_GOLD=100;
const BARON_XP=500, BARON_GOLD=150;
const DRAGON_BUFF_DURATION=15;
const BARON_BUFF_DURATION=12;

// ============ SHOP / ITEMS ============
const ITEMS=[
  {id:'dsword',name:'ë„ë€ì˜ ê²€',cost:100,ad:10,hp:80,icon:'ğŸ—¡ï¸'},
  {id:'dring',name:'ë„ë€ì˜ ë°˜ì§€',cost:100,ap:15,hp:60,icon:'ğŸ’'},
  {id:'boots',name:'ì¥í™”',cost:150,moveRange:1,icon:'ğŸ‘Ÿ'},
  {id:'longsword',name:'ë¡±ì†Œë“œ',cost:175,ad:15,icon:'âš”ï¸'},
  {id:'tome',name:'ì¦í­ì˜ ì„œ',cost:175,ap:25,icon:'ğŸ“•'},
  {id:'ruby',name:'ë£¨ë¹„ ìˆ˜ì •',cost:200,hp:150,icon:'ğŸ’'},
  {id:'cloth',name:'ì²œ ê°‘ì˜·',cost:150,armor:15,icon:'ğŸ›¡ï¸'},
  {id:'cloak',name:'ë§ˆë²• ë§í† ',cost:150,mr:20,icon:'ğŸ§¥'},
  {id:'bf',name:'B.F. ëŒ€ê²€',cost:350,ad:30,icon:'ğŸ”ª'},
  {id:'rod',name:'ì“¸ë°ì—†ì´ í° ì§€íŒ¡ì´',cost:350,ap:50,icon:'ğŸª„'},
  {id:'chain',name:'ì‡ ì‚¬ìŠ¬ ê°‘ì˜·',cost:300,armor:30,icon:'â›“ï¸'},
  {id:'potion',name:'ë¬¼ì•½',cost:50,healHp:120,consumable:true,icon:'ğŸ§ª'},
];

const ANNIE={
  name:'Annie',hp:560,mp:418,ad:50,ap:0,armor:19,mr:30,
  hpPerLvl:88,mpPerLvl:25,adPerLvl:2.7,armorPerLvl:4,mrPerLvl:1.3,
  skills:{
    passive:{name:'íŒŒì´ë¡œë§¤ë‹ˆì•„',stacksNeeded:4},
    q:{name:'ë¶•ê´´',key:'Q',baseDmg:[80,115,150,185,220],manaCost:60,cooldown:2,range:3,type:'target'},
    w:{name:'ì†Œê°',key:'W',baseDmg:[70,115,160,205,250],manaCost:70,cooldown:3,range:2,type:'aoe',aoeRadius:1},
    e:{name:'ë³´í˜¸ë§‰',key:'E',baseShield:[40,65,90,115,140],shieldApRatio:0.4,manaCost:40,cooldown:2,type:'self'},
    r:{name:'í‹°ë²„',key:'R',baseDmg:[150,275,400],manaCost:100,cooldown:6,range:3,type:'aoe',aoeRadius:1,summon:true}
  }
};

const MAX_LEVEL=18;
const XP_PER_LEVEL=[0,180,240,300,360,420,480,540,600,660,720,780,840,900,960,1020,1080,1140];
const MINION_XP=120, MINION_GOLD=25, CHAMPION_KILL_XP=300;
const SKILL_MAX={q:5,w:5,e:5,r:3};
const R_UNLOCK=[6,11,16];
const AI_SKILL_ORDER=['q','w','q','e','q','r','w','w','q','w','e','r','q','w','e','r','e','e'];

// ============ UTIL ============
function dist(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}
function isWalkable(x,y){return x>=0&&x<COLS&&y>=0&&y<ROWS&&MAP[y][x]===1;}

// ============ SKILL HELPERS ============
function getSkillDmg(key,lvl){const s=ANNIE.skills[key];if(!s.baseDmg||lvl<=0)return 0;return s.baseDmg[Math.min(lvl-1,s.baseDmg.length-1)]||0;}
function getShield(lvl){const s=ANNIE.skills.e;if(lvl<=0)return 0;return s.baseShield[Math.min(lvl-1,s.baseShield.length-1)]||0;}
function canLvlSkill(c,k){if(c.skillPoints<=0||c.skillLevels[k]>=SKILL_MAX[k])return false;if(k==='r'){const rl=c.skillLevels.r;return rl<3&&c.level>=R_UNLOCK[rl];}return true;}
function lvlSkill(c,k){if(!canLvlSkill(c,k))return;c.skillLevels[k]++;c.skillPoints--;log(`â¬†ï¸ ${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ${ANNIE.skills[k].key} ìŠ¤í‚¬ Lv.${c.skillLevels[k]}`,'log-heal');render();}
function aiAutoLvl(c){while(c.skillPoints>0){const t=c.skillLevels.q+c.skillLevels.w+c.skillLevels.e+c.skillLevels.r;const n=AI_SKILL_ORDER[t];if(n&&canLvlSkill(c,n)){c.skillLevels[n]++;c.skillPoints--;}else break;}}

// ============ STATE ============
let state;

function createChamp(team,x,y){
  const c={type:'champion',team,name:ANNIE.name,x,y,
    baseHp:ANNIE.hp,baseMp:ANNIE.mp,baseAd:ANNIE.ad,
    maxHp:ANNIE.hp,hp:ANNIE.hp,maxMp:ANNIE.mp,mp:ANNIE.mp,
    ad:ANNIE.ad,ap:ANNIE.ap,armor:ANNIE.armor,mr:ANNIE.mr,
    level:1,xp:0,skillPoints:1,skillLevels:{q:0,w:0,e:0,r:0},
    passiveStacks:0,shield:0,cooldowns:{q:0,w:0,e:0,r:0},
    tibbers:null,gold:0,alive:true,stunned:false,redBuff:0,blueBuff:0,dragonStacks:0,baronBuff:0,
    items:[],bonusAd:0,bonusAp:0,bonusHp:0,bonusArmor:0,bonusMr:0,bonusMoveRange:0,
    flashCd:0};
  recalc(c);return c;
}
function recalc(c){
  const l=c.level;
  c.maxHp=Math.floor(c.baseHp+ANNIE.hpPerLvl*(l-1))+c.bonusHp;
  c.maxMp=Math.floor(c.baseMp+ANNIE.mpPerLvl*(l-1));
  c.ad=Math.floor(c.baseAd+ANNIE.adPerLvl*(l-1))+c.bonusAd;
  c.ap=(c.baseAp||0)+c.bonusAp;
  c.armor=Math.floor(ANNIE.armor+ANNIE.armorPerLvl*(l-1))+c.bonusArmor;
  c.mr=Math.floor(ANNIE.mr+ANNIE.mrPerLvl*(l-1))+c.bonusMr;
}
function buyItem(champ,itemId){
  const item=ITEMS.find(i=>i.id===itemId);
  if(!item||champ.gold<item.cost)return false;
  if(!item.consumable&&champ.items.length>=6)return false;
  champ.gold-=item.cost;
  if(item.consumable){
    if(item.healHp){champ.hp=Math.min(champ.maxHp,champ.hp+item.healHp);}
    log(`${champ.team==='blue'?'ğŸ”µ':'ğŸ”´'} ${item.icon} ${item.name} ì‚¬ìš©! HP+${item.healHp}`,'log-heal');
    return true;
  }
  champ.items.push(itemId);
  if(item.ad)champ.bonusAd+=item.ad;
  if(item.ap)champ.bonusAp+=item.ap;
  if(item.hp){champ.bonusHp+=item.hp;}
  if(item.armor)champ.bonusArmor+=item.armor;
  if(item.mr)champ.bonusMr+=item.mr;
  if(item.moveRange)champ.bonusMoveRange+=item.moveRange;
  recalc(champ);
  champ.hp=Math.min(champ.maxHp,champ.hp+((item.hp)||0));
  log(`${champ.team==='blue'?'ğŸ”µ':'ğŸ”´'} ${item.icon} ${item.name} êµ¬ë§¤!`,'log-info');
  return true;
}
function grantXP(c,amt){
  if(c.level>=MAX_LEVEL)return;
  c.xp+=amt;
  while(c.level<MAX_LEVEL&&c.xp>=XP_PER_LEVEL[c.level]){
    c.xp-=XP_PER_LEVEL[c.level];c.level++;c.skillPoints++;
    const oh=c.maxHp,om=c.maxMp;recalc(c);
    c.hp+=c.maxHp-oh;c.mp+=c.maxMp-om;
    const cl=c.team==='blue'?'ğŸ”µ':'ğŸ”´';
    log(`â¬†ï¸ ${cl} ë ˆë²¨ ì—…! Lv.${c.level}`,'log-heal');
    if(c.team==='red')aiAutoLvl(c);
  }
}
function calcDmg(raw,type,tgt){
  const ds=(tgt.dragonStacks||0)*3;
  const d=type==='magic'?(tgt.mr||0)+ds:(tgt.armor||0)+ds;
  return Math.max(1,Math.floor(raw*(100/(100+d))));
}
function applyDmg(tgt,amt){
  if(tgt.shield>0){if(tgt.shield>=amt){tgt.shield-=amt;return 0;}amt-=tgt.shield;tgt.shield=0;}
  tgt.hp=Math.max(0,tgt.hp-amt);if(tgt.hp<=0)tgt.alive=false;return amt;
}

function initGame(){
  state={
    turn:1,
    player:createChamp('blue',2,3),
    enemy:createChamp('red',12,3),
    minions:MINION_POSITIONS.map((p,i)=>({type:'minion',x:p.x,y:p.y,alive:true,id:i})),
    buffs:BUFF_POSITIONS.map(b=>({type:'buff',buffType:b.type,x:b.x,y:b.y,alive:true,hp:3,maxHp:3,armor:10,mr:10,lastKillTurn:0})),
    epics:EPIC_POSITIONS.map(e=>{const h=e.type==='dragon'?DRAGON_HP:BARON_HP;return{type:'epic',epicType:e.type,x:e.x,y:e.y,alive:true,hp:h,maxHp:h,armor:20,mr:20,lastKillTurn:0};}),
    tibbersList:[],
    logs:[],
    // Phase: 'plan' = choosing action, 'target' = choosing target cell
    phase:'plan',
    playerAction:null, // {type:'move'|'attack'|'skill',dir?,target?,key?}
    aiAction:null,
    targetMode:null, // null or {type,key,range}
    lastRevealTurn:0,
    lastEnemyReveal:null, // {x,y,hp,maxHp,mp,maxMp,level} shown during reveal
    gameOver:false
  };
  aiAutoLvl(state.enemy);
  spawnMinions();
  planPhase();
  log(`â”â”â” í„´ ${state.turn} â”â”â”`,'log-turn');
  log('ğŸ“ ì  ìœ„ì¹˜ëŠ” 5í„´ë§ˆë‹¤ ê³µê°œë©ë‹ˆë‹¤','log-info');
  render();
}
function restartGame(){
  document.getElementById('game-over-overlay').classList.remove('show','victory','defeat');
  initGame();
}
function log(msg,cls=''){state.logs.push({msg,cls});}

// ============ MINIONS ============
function spawnMinions(){
  state.minions.forEach((m,i)=>{
    if(!m.alive){m.alive=true;m.x=MINION_POSITIONS[i].x;m.y=MINION_POSITIONS[i].y;}
  });
}

// ============ TURN PHASES ============
function planPhase(){
  state.phase='plan';
  state.playerAction=null;
  state.targetMode=null;
  // AI decides blindly (no knowledge of player's choice)
  state.aiAction=aiDecideAction();
  render();
}

function aiDecideAction(){
  const ai=state.enemy,p=state.player;
  if(!ai.alive)return{type:'wait',desc:'ëŒ€ê¸°'};
  if(ai.stunned)return{type:'wait',desc:'âš¡ ìŠ¤í„´ ìƒíƒœ'};

  // Try to find and kill nearby minion for gold/xp
  const nearMinion=state.minions.find(m=>m.alive&&dist({x:ai.x,y:ai.y},{x:m.x,y:m.y})<=1);
  if(nearMinion)return{type:'attack',target:{x:nearMinion.x,y:nearMinion.y},desc:`âš”ï¸ í‰íƒ€ â†’ (${nearMinion.x},${nearMinion.y})`};

  // AI only knows player position if revealed recently (within 2 turns)
  const knowsPlayer=state.lastRevealTurn>0&&(state.turn-state.lastRevealTurn)<=2;
  // AI's guess of player position â€” last known or random
  let guessX=p.x, guessY=p.y; // only accurate if knowsPlayer
  if(!knowsPlayer&&state.lastEnemyReveal){
    // AI remembers player's last revealed position but it's stale â€” guess nearby
    // Not accurate, just a rough area guess
    guessX=state.lastPlayerRevealX||(COLS>>1);
    guessY=state.lastPlayerRevealY||(ROWS>>1);
  }

  if(knowsPlayer){
    const dToP=dist({x:ai.x,y:ai.y},{x:p.x,y:p.y});

    // Flash + skill combo: if out of range but flash can close the gap
    if(ai.flashCd===0&&dToP>3&&dToP<=3+FLASH_RANGE){
      // Flash toward player to get in skill range
      let bestFlash=null,bestFD=999;
      for(let fy=1;fy<ROWS-1;fy++)for(let fx=1;fx<COLS-1;fx++){
        const fd=dist({x:ai.x,y:ai.y},{x:fx,y:fy});
        const dp=dist({x:fx,y:fy},{x:p.x,y:p.y});
        if(fd>=1&&fd<=FLASH_RANGE&&isWalkable(fx,fy)&&dp<=3&&dp<bestFD){bestFD=dp;bestFlash={x:fx,y:fy};}
      }
      if(bestFlash&&ai.skillLevels.r>0&&ai.cooldowns.r===0&&ai.mp>=100){
        execFlash(ai,bestFlash.x,bestFlash.y);
        return{type:'skill',key:'r',target:{x:p.x,y:p.y},desc:`ğŸ”¥ R í‹°ë²„ â†’ (${p.x},${p.y})`};
      }
      if(bestFlash&&ai.skillLevels.q>0&&ai.cooldowns.q===0&&ai.mp>=60){
        execFlash(ai,bestFlash.x,bestFlash.y);
        return{type:'skill',key:'q',target:{x:p.x,y:p.y},desc:`Q ë¶•ê´´ â†’ (${p.x},${p.y})`};
      }
    }

    if(ai.skillLevels.r>0&&ai.cooldowns.r===0&&ai.mp>=100&&dToP<=3){
      return{type:'skill',key:'r',target:{x:p.x,y:p.y},desc:`ğŸ”¥ R í‹°ë²„ â†’ (${p.x},${p.y})`};
    }
    if(ai.skillLevels.q>0&&ai.cooldowns.q===0&&ai.mp>=60&&dToP<=3){
      return{type:'skill',key:'q',target:{x:p.x,y:p.y},desc:`Q ë¶•ê´´ â†’ (${p.x},${p.y})`};
    }
    if(ai.skillLevels.w>0&&ai.cooldowns.w===0&&ai.mp>=70&&dToP<=2){
      return{type:'skill',key:'w',target:{x:p.x,y:p.y},desc:`W ì†Œê° â†’ (${p.x},${p.y})`};
    }
  }

  if(ai.skillLevels.e>0&&ai.cooldowns.e===0&&ai.shield===0&&ai.mp>=40){
    return{type:'skill',key:'e',desc:'E ë³´í˜¸ë§‰'};
  }

  // AI shop: buy best affordable item
  if(ai.items.length<6){
    const affordable=ITEMS.filter(i=>!i.consumable&&ai.gold>=i.cost).sort((a,b)=>b.cost-a.cost);
    if(affordable.length>0){
      const best=affordable[0];
      return{type:'shop',itemId:best.id,desc:`ğŸ›’ ìƒì  ì´ìš©`};
    }
  }
  // Buy potion if low HP
  if(ai.hp<ai.maxHp*0.4&&ai.gold>=50){
    return{type:'shop',itemId:'potion',desc:`ğŸ›’ ìƒì  ì´ìš©`};
  }

  // Move toward nearest minion or wander
  const aliveMinions=state.minions.filter(m=>m.alive);
  let bestMinion=null,bestDist=999;
  for(const m of aliveMinions){const d=dist({x:ai.x,y:ai.y},{x:m.x,y:m.y});if(d<bestDist){bestDist=d;bestMinion=m;}}

  if(bestMinion){
    const dx=Math.sign(bestMinion.x-ai.x),dy=Math.sign(bestMinion.y-ai.y);
    if(dx!==0&&isWalkable(ai.x+dx,ai.y))return{type:'move',dir:{x:dx,y:0},desc:`ğŸš¶ ì´ë™`};
    if(dy!==0&&isWalkable(ai.x,ai.y+dy))return{type:'move',dir:{x:0,y:dy},desc:`ğŸš¶ ì´ë™`};
  }

  return{type:'wait',desc:'ëŒ€ê¸°'};
}

// ============ PLAYER ACTIONS ============
function setPlayerMove(){
  state.phase='target';
  state.targetMode={type:'move'};
  render();
}
function setPlayerAttack(){
  state.phase='target';
  state.targetMode={type:'attack',range:2};
  render();
}
function setPlayerSkill(key){
  const p=state.player,s=ANNIE.skills[key];
  if(p.skillLevels[key]<=0||p.cooldowns[key]>0||p.mp<s.manaCost)return;
  if(s.type==='self'){
    state.playerAction={type:'skill',key,desc:`E ë³´í˜¸ë§‰`};
    state.phase='plan';
    render();return;
  }
  state.phase='target';
  state.targetMode={type:'skill',key,range:s.range};
  render();
}
function selectCell(x,y){
  if(!state.targetMode)return;
  const tm=state.targetMode;
  const p=state.player;

  if(tm.type==='flash'){
    if(dist({x:p.x,y:p.y},{x,y})>FLASH_RANGE||dist({x:p.x,y:p.y},{x,y})<1)return;
    if(!isWalkable(x,y))return;
    execFlash(p,x,y);
    state.phase='plan';
    state.targetMode=null;
    render();return;
  } else if(tm.type==='move'){
    const dx=x-p.x,dy=y-p.y;
    const mRange=1+(p.bonusMoveRange||0);
    if(Math.abs(dx)+Math.abs(dy)>mRange||Math.abs(dx)+Math.abs(dy)<1)return;
    if(!isWalkable(x,y))return;
    state.playerAction={type:'move',dir:{x:dx,y:dy},dest:{x,y},desc:`ğŸš¶ ì´ë™`};
  } else if(tm.type==='attack'){
    if(dist({x:p.x,y:p.y},{x,y})>tm.range)return;
    state.playerAction={type:'attack',target:{x,y},desc:`âš”ï¸ í‰íƒ€ â†’ (${x},${y})`};
  } else if(tm.type==='skill'){
    const s=ANNIE.skills[tm.key];
    if(dist({x:p.x,y:p.y},{x,y})>s.range)return;
    state.playerAction={type:'skill',key:tm.key,target:{x,y},desc:`${s.key} ${s.name} â†’ (${x},${y})`};
  }
  state.phase='plan';
  state.targetMode=null;
  render();
}
function cancelTarget(){
  state.phase='plan';
  state.targetMode=null;
  render();
}

// ============ FLASH (ì ë©¸) ============
const FLASH_CD=24;
const FLASH_RANGE=3;
function setPlayerFlash(){
  if(state.player.flashCd>0||!state.player.alive||state.player.stunned)return;
  state.phase='target';
  state.targetMode={type:'flash',range:FLASH_RANGE};
  render();
}
function execFlash(champ,x,y){
  if(champ.flashCd>0||!champ.alive)return false;
  if(!isWalkable(x,y))return false;
  if(dist({x:champ.x,y:champ.y},{x,y})>FLASH_RANGE||dist({x:champ.x,y:champ.y},{x,y})<1)return false;
  const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
  champ.x=x;champ.y=y;
  champ.flashCd=FLASH_CD;
  log(`âœ¨ ${cl} ì ë©¸!`,'log-info');
  // Flash effect
  ultFlash('rgba(255,255,100,0.3)');
  return true;
}

function toggleShop(){
  const el=document.getElementById('shop');
  if(el.style.display==='block'){el.style.display='none';return;}
  el.style.display='block';
  renderShop();
}
function renderShop(){
  const el=document.getElementById('shop');
  const p=state.player;
  let html=`<h4>ğŸ›’ ìƒì  â€” ğŸ’° ${p.gold}G (ì•„ì´í…œ ${p.items.length}/6) â€” êµ¬ë§¤ = í„´ ì†Œëª¨</h4><div class="shop-grid">`;
  ITEMS.forEach(item=>{
    const canBuy=p.gold>=item.cost&&(item.consumable||p.items.length<6);
    let stats=[];
    if(item.ad)stats.push(`AD+${item.ad}`);
    if(item.ap)stats.push(`AP+${item.ap}`);
    if(item.hp)stats.push(`HP+${item.hp}`);
    if(item.armor)stats.push(`ë°©ì–´+${item.armor}`);
    if(item.mr)stats.push(`ë§ˆì €+${item.mr}`);
    if(item.moveRange)stats.push(`ì´ë™+${item.moveRange}`);
    if(item.healHp)stats.push(`íšŒë³µ${item.healHp}`);
    if(item.consumable)stats.push('ì†Œëª¨í’ˆ');
    html+=`<div class="shop-item ${canBuy?'':'cant'}" onclick="${canBuy?`shopBuy('${item.id}')`:''}">`+
      `<span class="item-name">${item.icon} ${item.name}</span> `+
      `<span class="item-cost">${item.cost}G</span><br>`+
      `<span class="item-stats">${stats.join(' ')}</span></div>`;
  });
  html+=`</div><button style="margin-top:8px;background:#222;color:#e0e0e0;border:1px solid #555;padding:5px 12px;cursor:pointer;border-radius:4px;font-family:inherit;font-size:11px" onclick="toggleShop()">ë‹«ê¸°</button>`;
  el.innerHTML=html;
}
function shopBuy(itemId){
  const p=state.player;
  if(buyItem(p,itemId)){
    state.playerAction={type:'shop',desc:`ğŸ›’ ìƒì  ì´ìš©`};
    document.getElementById('shop').style.display='none';
    render();
  }
}

function confirmActions(){
  if(!state.playerAction){log('âš ï¸ í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš”','log-info');render();return;}
  // Blind simultaneous â€” both committed, execute immediately
  executeTurn();
}

// ============ EXECUTE TURN ============
function executeTurn(){
  const p=state.player,e=state.enemy;
  const pa=state.playerAction,aa=state.aiAction;

  // Log actions (move hides coordinates for both sides)
  log(`ğŸ”µ ${pa.desc}`,'log-info');
  log(`ğŸ”´ ${aa.desc}`,'log-info');

  // Execute both simultaneously
  executeAction(p,pa);
  executeAction(e,aa);

  if(checkGameOver()){render();return;}

  // Cooldown tick
  for(let k of['q','w','e','r']){if(p.cooldowns[k]>0)p.cooldowns[k]--;if(e.cooldowns[k]>0)e.cooldowns[k]--;}
  if(p.flashCd>0)p.flashCd--;if(e.flashCd>0)e.flashCd--;
  p.stunned=false;e.stunned=false;
  p.mp=Math.min(p.maxMp,p.mp+(p.blueBuff>0?20:10));
  e.mp=Math.min(e.maxMp,e.mp+(e.blueBuff>0?20:10));

  // Minion respawn
  if(state.turn%MINION_RESPAWN_INTERVAL===0){
    spawnMinions();
    log('ğŸ”„ ë¯¸ë‹ˆì–¸ ë¦¬ì  !','log-info');
  }

  // Buff respawn
  state.buffs.forEach(b=>{
    if(!b.alive&&b.lastKillTurn>0&&(state.turn-b.lastKillTurn)>=BUFF_RESPAWN){
      b.alive=true;b.hp=b.maxHp;
      log(`ğŸ’ ${b.buffType==='red'?'ğŸ”´ ë ˆë“œ':'ğŸ”µ ë¸”ë£¨'} ë²„í”„ ëª¬ìŠ¤í„° ë¦¬ì  !`,'log-info');
    }
  });

  // Epic monster respawn
  state.epics.forEach(e=>{
    if(!e.alive&&e.lastKillTurn>0&&(state.turn-e.lastKillTurn)>=EPIC_RESPAWN){
      e.alive=true;e.hp=e.maxHp;
      log(`ğŸ‘‘ ${e.epicType==='dragon'?'ğŸ‰ ë“œë˜ê³¤':'ğŸ‘¿ ë°”ë¡ '} ë¦¬ì  !`,'log-info');
    }
  });

  // Tick buff durations
  [state.player,state.enemy].forEach(c=>{
    if(c.redBuff&&c.redBuff>0){c.redBuff--;if(c.redBuff===0)log(`${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ë ˆë“œ ë²„í”„ ë§Œë£Œ`,'log-info');}
    if(c.blueBuff&&c.blueBuff>0){c.blueBuff--;if(c.blueBuff===0)log(`${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ë¸”ë£¨ ë²„í”„ ë§Œë£Œ`,'log-info');}
    // dragonStacksëŠ” ì˜êµ¬ â€” tick ë¶ˆí•„ìš”
    if(c.baronBuff&&c.baronBuff>0){c.baronBuff--;if(c.baronBuff===0)log(`${c.team==='blue'?'ğŸ”µ':'ğŸ”´'} ë°”ë¡  ë²„í”„ ë§Œë£Œ`,'log-info');}
  });

  // Reveal check
  if(state.turn%REVEAL_INTERVAL===0){
    state.lastRevealTurn=state.turn;
    state.lastEnemyReveal={x:e.x,y:e.y,hp:e.hp,maxHp:e.maxHp,mp:e.mp,maxMp:e.maxMp,level:e.level};
    // AI also learns player position on reveal
    state.lastPlayerRevealX=p.x;
    state.lastPlayerRevealY=p.y;
    log(`ğŸ‘ï¸ ì  ìœ„ì¹˜ ê³µê°œ! (${e.x},${e.y}) HP:${e.hp}/${e.maxHp} MP:${e.mp}/${e.maxMp} Lv.${e.level}`,'log-reveal');
  }

  state.turn++;
  log(`â”â”â” í„´ ${state.turn} â”â”â”`,'log-turn');

  // Tibbers AI
  tibbersAI();

  cleanDead();
  if(checkGameOver()){render();return;}
  planPhase();
}

function executeAction(champ,action){
  if(!champ.alive||!action)return;
  if(champ.stunned)return;

  if(action.type==='shop'){
    if(action.itemId)buyItem(champ,action.itemId);
    return;
  }
  if(action.type==='move'){
    const nx=action.dest?action.dest.x:champ.x+action.dir.x;
    const ny=action.dest?action.dest.y:champ.y+action.dir.y;
    if(isWalkable(nx,ny)){champ.x=nx;champ.y=ny;}
  }
  else if(action.type==='attack'){
    const tx=action.target.x,ty=action.target.y;
    if(dist({x:champ.x,y:champ.y},{x:tx,y:ty})>2)return;

    // Check minion at target
    const minion=state.minions.find(m=>m.alive&&m.x===tx&&m.y===ty);
    if(minion){
      minion.alive=false;
      grantXP(champ,MINION_XP);champ.gold+=MINION_GOLD;
      const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      log(`${cl} ë¯¸ë‹ˆì–¸ ì²˜ì¹˜ (${tx},${ty}) +${MINION_GOLD}G +${MINION_XP}XP`,'log-kill');
    }

    // Check enemy champion at target
    const enemy=champ.team==='blue'?state.enemy:state.player;
    if(enemy.alive&&enemy.x===tx&&enemy.y===ty){
      const atkAd=champ.ad+(champ.redBuff>0?15:0)+(champ.dragonStacks||0)*5;
      const dmg=calcDmg(atkAd,'physical',enemy);
      applyDmg(enemy,dmg);
      const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´',tl=enemy.team==='blue'?'ğŸ”µ':'ğŸ”´';
      let dmgLog=`${cl} í‰íƒ€ ì ì¤‘! â†’ ${tl} ${dmg} í”¼í•´`;
      if(champ.redBuff>0){const burn=Math.max(1,Math.floor(dmg*0.15));applyDmg(enemy,burn);dmgLog+=` +ğŸ”¥${burn}`;}
      log(dmgLog,'log-dmg');
      if(!enemy.alive){champ.gold+=300;grantXP(champ,CHAMPION_KILL_XP);log(`${cl} ì±”í”¼ì–¸ ì²˜ì¹˜!`,'log-kill');}
    }
    else if(!minion){
      const cl=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      log(`${cl} í‰íƒ€ ë¹—ë‚˜ê° (${tx},${ty})`,'log-miss');
    }

    // Check buff monster at target
    const buff=state.buffs.find(b=>b.alive&&b.x===tx&&b.y===ty);
    if(buff){
      buff.hp--;
      const cl2=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      if(buff.hp<=0){
        buff.alive=false;buff.lastKillTurn=state.turn;
        if(buff.buffType==='red'){champ.redBuff=BUFF_DURATION;log(`${cl2} ğŸ”´ ë ˆë“œ ë²„í”„ íšë“! (AD+15, í‰íƒ€ í™”ìƒ)`,`log-kill`);}
        else{champ.blueBuff=BUFF_DURATION;log(`${cl2} ğŸ”µ ë¸”ë£¨ ë²„í”„ íšë“! (ë§ˆë‚˜ íšŒë³µ 2ë°°)`,`log-kill`);}
        grantXP(champ,BUFF_XP);champ.gold+=BUFF_GOLD;
        log(`${cl2} +${BUFF_XP}XP +${BUFF_GOLD}G`,'log-kill');
      } else {
        log(`${cl2} ë²„í”„ ëª¬ìŠ¤í„° ê³µê²© (${buff.hp}/${buff.maxHp})`,'log-dmg');
      }
    }

    // Check epic monster at target
    const epic=state.epics.find(e=>e.alive&&e.x===tx&&e.y===ty);
    if(epic){
      epic.hp--;
      const cl3=champ.team==='blue'?'ğŸ”µ':'ğŸ”´';
      if(epic.hp<=0){
        epic.alive=false;epic.lastKillTurn=state.turn;
        if(epic.epicType==='dragon'){
          champ.dragonStacks=(champ.dragonStacks||0)+1;
          const dheal=Math.floor(champ.maxHp*0.1);champ.hp=Math.min(champ.maxHp,champ.hp+dheal);
          grantXP(champ,DRAGON_XP);champ.gold+=DRAGON_GOLD;
          const ds=champ.dragonStacks;
          log(`${cl3} ğŸ‰ ë“œë˜ê³¤ ì²˜ì¹˜! (${ds}ì¤‘ì²©) HPíšŒë³µ+${dheal}, AD+${ds*5}, AP+${ds*10}, ë°©ì–´+${ds*3}`,'log-kill');
        } else {
          champ.baronBuff=BARON_BUFF_DURATION;
          grantXP(champ,BARON_XP);champ.gold+=BARON_GOLD;
          log(`${cl3} ğŸ‘¿ ë°”ë¡  ì²˜ì¹˜! ìŠ¤í‚¬ ë°ë¯¸ì§€ +30% (${BARON_BUFF_DURATION}í„´)`,'log-kill');
        }
      } else {
        log(`${cl3} ${epic.epicType==='dragon'?'ğŸ‰ ë“œë˜ê³¤':'ğŸ‘¿ ë°”ë¡ '} ê³µê²© (${epic.hp}/${epic.maxHp})`,'log-dmg');
      }
    }

    // Check tibbers at target
    const tib=state.tibbersList.find(t=>t.alive&&t.x===tx&&t.y===ty&&t.team!==champ.team);
    if(tib){const dmg=calcDmg(champ.ad,'physical',tib);applyDmg(tib,dmg);}
  }
  else if(action.type==='skill'){
    const key=action.key;
    execSkill(champ,key,action.target);
  }
}

function execSkill(caster,key,target){
  const skill=ANNIE.skills[key];
  if(caster.cooldowns[key]>0||caster.mp<skill.manaCost)return;
  const sLvl=caster.skillLevels[key];if(sLvl<=0)return;

  caster.mp-=skill.manaCost;
  caster.cooldowns[key]=skill.cooldown;
  caster.passiveStacks++;
  let willStun=false;
  if(caster.passiveStacks>=ANNIE.skills.passive.stacksNeeded){willStun=true;caster.passiveStacks=0;}
  const cl=caster.team==='blue'?'ğŸ”µ':'ğŸ”´';

  if(key==='e'){
    const s=Math.floor(getShield(sLvl)+skill.shieldApRatio*caster.ap);
    caster.shield+=s;
    log(`${cl} E ë³´í˜¸ë§‰ +${s}`,'log-info');
    return;
  }
  if(!target)return;
  if(dist({x:caster.x,y:caster.y},target)>skill.range)return;

  let raw=getSkillDmg(key,sLvl)+caster.ap+(caster.dragonStacks||0)*10;
  if(caster.baronBuff>0)raw=Math.floor(raw*1.3); // baron: +30% skill dmg
  const enemy=caster.team==='blue'?state.enemy:state.player;
  const aoeR=skill.aoeRadius||0;

  // Check hit on enemy
  let hitEnemy=false;
  if(enemy.alive){
    const d=dist(target,{x:enemy.x,y:enemy.y});
    if(d<=aoeR){
      const dmg=calcDmg(raw,'magic',enemy);
      applyDmg(enemy,dmg);hitEnemy=true;
      const tl=enemy.team==='blue'?'ğŸ”µ':'ğŸ”´';
      if(key==='r'){
        screenShake();ultFlash(caster.team==='blue'?'rgba(100,0,255,0.4)':'rgba(255,0,100,0.4)');
        spawnParticles(25,caster.team==='blue'?'#8844ff':'#ff4488');
        log(`ğŸ”¥ğŸ§¸ ${cl} ì†Œí™˜:í‹°ë²„!! â†’ ${tl} ${dmg} ì ì¤‘!`,'log-ult');
      } else {
        log(`${cl} ${ANNIE.skills[key].key} â†’ ${tl} ${dmg} ì ì¤‘!`,'log-dmg');
      }
      if(willStun){enemy.stunned=true;log(`âš¡ íŒŒì´ë¡œë§¤ë‹ˆì•„! ìŠ¤í„´!`,'log-kill');}
      if(!enemy.alive){caster.gold+=300;grantXP(caster,CHAMPION_KILL_XP);log(`${cl} ì±”í”¼ì–¸ ì²˜ì¹˜!`,'log-kill');}
      if(key==='q'&&!enemy.alive){caster.mp=Math.min(caster.maxMp,caster.mp+skill.manaCost);log('ğŸ’° Q ì²˜ì¹˜ ë§ˆë‚˜ íšŒë³µ!','log-heal');}
    }
  }

  // Check minions in AoE
  state.minions.filter(m=>m.alive&&dist(target,{x:m.x,y:m.y})<=aoeR).forEach(m=>{
    m.alive=false;grantXP(caster,MINION_XP);caster.gold+=MINION_GOLD;
    log(`${cl} ë¯¸ë‹ˆì–¸ ì²˜ì¹˜ (${m.x},${m.y}) +${MINION_GOLD}G`,'log-kill');
  });

  // Check epic monsters in AoE
  state.epics.filter(e=>e.alive&&dist(target,{x:e.x,y:e.y})<=aoeR).forEach(e=>{
    e.hp--;
    if(e.hp<=0){
      e.alive=false;e.lastKillTurn=state.turn;
      if(e.epicType==='dragon'){
        caster.dragonStacks=(caster.dragonStacks||0)+1;
        const dheal2=Math.floor(caster.maxHp*0.1);caster.hp=Math.min(caster.maxHp,caster.hp+dheal2);
        grantXP(caster,DRAGON_XP);caster.gold+=DRAGON_GOLD;
        const ds2=caster.dragonStacks;
        log(`${cl} ğŸ‰ ë“œë˜ê³¤ ì²˜ì¹˜! (${ds2}ì¤‘ì²©) HPíšŒë³µ+${dheal2}, AD+${ds2*5}, AP+${ds2*10}, ë°©ì–´+${ds2*3}`,'log-kill');
      } else {
        caster.baronBuff=BARON_BUFF_DURATION;
        grantXP(caster,BARON_XP);caster.gold+=BARON_GOLD;
        log(`${cl} ğŸ‘¿ ë°”ë¡  ì²˜ì¹˜! ìŠ¤í‚¬ ë°ë¯¸ì§€ +30% (${BARON_BUFF_DURATION}í„´)`,'log-kill');
      }
    }
  });

  // Check buff monsters in AoE
  state.buffs.filter(b=>b.alive&&dist(target,{x:b.x,y:b.y})<=aoeR).forEach(b=>{
    b.hp--;
    if(b.hp<=0){
      b.alive=false;b.lastKillTurn=state.turn;
      if(b.buffType==='red'){caster.redBuff=BUFF_DURATION;log(`${cl} ğŸ”´ ë ˆë“œ ë²„í”„ íšë“!`,'log-kill');}
      else{caster.blueBuff=BUFF_DURATION;log(`${cl} ğŸ”µ ë¸”ë£¨ ë²„í”„ íšë“!`,'log-kill');}
      grantXP(caster,BUFF_XP);caster.gold+=BUFF_GOLD;
    }
  });

  // Check tibbers
  state.tibbersList.filter(t=>t.alive&&t.team!==caster.team&&dist(target,{x:t.x,y:t.y})<=aoeR).forEach(t=>{
    const dmg=calcDmg(raw,'magic',t);applyDmg(t,dmg);
  });

  if(!hitEnemy&&key!=='r'){
    log(`${cl} ${ANNIE.skills[key].key} â†’ (${target.x},${target.y}) ë¹—ë‚˜ê°`,'log-miss');
  }

  // Summon tibbers
  if(key==='r'&&skill.summon&&!caster.tibbers){
    if(!hitEnemy){
      log(`ğŸ”¥ğŸ§¸ ${cl} ì†Œí™˜:í‹°ë²„!! â†’ (${target.x},${target.y})`,'log-ult');
      screenShake();ultFlash(caster.team==='blue'?'rgba(100,0,255,0.4)':'rgba(255,0,100,0.4)');
    }
    const tib={type:'tibbers',team:caster.team,x:target.x,y:target.y,hp:300,maxHp:300,ad:40,alive:true,armor:0,mr:0};
    caster.tibbers=tib;state.tibbersList.push(tib);
  }
}

// ============ TIBBERS AI ============
function tibbersAI(){
  for(const tib of state.tibbersList){
    if(!tib.alive)continue;
    const enemy=tib.team==='blue'?state.enemy:state.player;
    if(enemy.alive&&dist({x:tib.x,y:tib.y},{x:enemy.x,y:enemy.y})<=1){
      const dmg=calcDmg(tib.ad,'physical',enemy);applyDmg(enemy,dmg);
      log(`ğŸ§¸ í‹°ë²„ â†’ ${enemy.team==='blue'?'ğŸ”µ':'ğŸ”´'} ${dmg}`,'log-dmg');
      if(!enemy.alive)log('ğŸ§¸ í‹°ë²„ê°€ ì±”í”¼ì–¸ ì²˜ì¹˜!','log-kill');
    }else if(enemy.alive){
      const dx=Math.sign(enemy.x-tib.x),dy=Math.sign(enemy.y-tib.y);
      if(dx!==0&&isWalkable(tib.x+dx,tib.y))tib.x+=dx;
      else if(dy!==0&&isWalkable(tib.x,tib.y+dy))tib.y+=dy;
    }
  }
}

function cleanDead(){
  state.tibbersList=state.tibbersList.filter(t=>t.alive);
  if(state.player.tibbers&&!state.player.tibbers.alive)state.player.tibbers=null;
  if(state.enemy.tibbers&&!state.enemy.tibbers.alive)state.enemy.tibbers=null;
}

// ============ EFFECTS ============
function screenShake(){document.getElementById('game').classList.add('screen-shake');setTimeout(()=>document.getElementById('game').classList.remove('screen-shake'),400);}
function ultFlash(c){const o=document.getElementById('ult-overlay');o.style.background=c;o.classList.add('flash');setTimeout(()=>o.classList.remove('flash'),200);}
function spawnParticles(n,c){for(let i=0;i<n;i++){const p=document.createElement('div');p.className='particle';const s=4+Math.random()*8;p.style.width=s+'px';p.style.height=s+'px';p.style.background=c;p.style.boxShadow=`0 0 ${s}px ${c}`;p.style.left=(20+Math.random()*60)+'vw';p.style.top=(20+Math.random()*60)+'vh';document.body.appendChild(p);setTimeout(()=>p.remove(),1500);}}
function showGameOver(v){
  const ov=document.getElementById('game-over-overlay'),txt=document.getElementById('game-over-text'),sub=document.getElementById('game-over-sub');
  if(v){ov.classList.add('show','victory');txt.textContent='VICTORY';sub.textContent='ì  ì±”í”¼ì–¸ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!';spawnParticles(40,'#f0c040');setTimeout(()=>spawnParticles(30,'#ff8800'),300);}
  else{ov.classList.add('show','defeat');txt.textContent='DEFEAT';sub.textContent='ì±”í”¼ì–¸ì´ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...';screenShake();setTimeout(()=>screenShake(),300);}
}
function checkGameOver(){
  if(!state.player.alive){state.gameOver=true;showGameOver(false);return true;}
  if(!state.enemy.alive){state.gameOver=true;showGameOver(true);return true;}
  return false;
}

// ============ RENDER ============
function render(){renderMap();renderStats();renderPhase();renderActions();renderLog();}

function renderMap(){
  const mapEl=document.getElementById('map');
  const p=state.player;
  const isRevealTurn=state.lastRevealTurn===state.turn||(state.lastRevealTurn===state.turn-1);
  const revealPos=state.lastEnemyReveal;

  // Target mode cells
  const targetCells=new Set();
  const moveCells=new Set();
  if(state.targetMode){
    if(state.targetMode.type==='flash'){
      for(let y2=1;y2<ROWS-1;y2++)for(let x2=1;x2<COLS-1;x2++){
        const d=dist({x:p.x,y:p.y},{x:x2,y:y2});
        if(d>=1&&d<=FLASH_RANGE&&isWalkable(x2,y2))moveCells.add(x2+','+y2);
      }
    }else if(state.targetMode.type==='move'){
      const mRange=1+(p.bonusMoveRange||0);
      for(let dy=-mRange;dy<=mRange;dy++)for(let dx=-mRange;dx<=mRange;dx++){
        if(Math.abs(dx)+Math.abs(dy)<1||Math.abs(dx)+Math.abs(dy)>mRange)continue;
        const nx=p.x+dx,ny=p.y+dy;if(isWalkable(nx,ny))moveCells.add(nx+','+ny);
      }
    }else if(state.targetMode.type==='attack'){
      // Auto-attack: only cells with visible units
      const range=state.targetMode.range||2;
      for(let y=1;y<ROWS-1;y++)for(let x=1;x<COLS-1;x++){
        if(dist({x:p.x,y:p.y},{x,y})>range)continue;
        const hasMinion=state.minions.some(m=>m.alive&&m.x===x&&m.y===y);
        const hasBuff=state.buffs.some(b=>b.alive&&b.x===x&&b.y===y);
        const hasEpic=state.epics.some(e=>e.alive&&e.x===x&&e.y===y);
        const hasTib=state.tibbersList.some(t=>t.alive&&t.x===x&&t.y===y&&t.team!=='blue');
        // Enemy champion visible on reveal turn
        const isReveal=state.lastRevealTurn===state.turn;
        const hasEnemy=isReveal&&state.enemy.alive&&state.enemy.x===x&&state.enemy.y===y;
        if(hasMinion||hasBuff||hasEpic||hasTib||hasEnemy)targetCells.add(x+','+y);
      }
    }else{
      // Skills: any cell in range (can target empty cells)
      const range=state.targetMode.range||3;
      for(let y=1;y<ROWS-1;y++)for(let x=1;x<COLS-1;x++){
        if(dist({x:p.x,y:p.y},{x,y})<=range)targetCells.add(x+','+y);
      }
    }
  }

  let html='<table>';
  // Column headers
  html+='<tr><td class="wall" style="width:24px;height:24px;font-size:9px;color:#555"></td>';
  for(let x=0;x<COLS;x++)html+=`<td class="wall" style="height:24px;font-size:9px;color:#555;border:none">${x}</td>`;
  html+='</tr>';
  for(let y=0;y<ROWS;y++){
    html+=`<tr><td class="wall" style="width:24px;font-size:9px;color:#555;border:none">${y}</td>`;
    for(let x=0;x<COLS;x++){
      const w=MAP[y][x]===0;
      let cls=w?'wall':'walkable';
      const k=x+','+y;
      if(moveCells.has(k))cls+=' highlight';
      else if(targetCells.has(k))cls+=' target-mode';
      // Reveal flash
      if(isRevealTurn&&revealPos&&revealPos.x===x&&revealPos.y===y)cls+=' reveal-flash';

      let content='';

      // Player
      if(p.alive&&p.x===x&&p.y===y){
        content=`<span class="unit">âš”ï¸</span><span class="sub">ğŸ”µë‚˜</span>`;
      }
      // Player's tibbers
      const myTib=state.tibbersList.find(t=>t.alive&&t.team==='blue'&&t.x===x&&t.y===y);
      if(myTib)content=`<span class="unit">ğŸ§¸</span><span class="sub">ğŸ”µ</span>`;

      // Enemy tibbers (visible)
      const eTib=state.tibbersList.find(t=>t.alive&&t.team==='red'&&t.x===x&&t.y===y);
      if(eTib)content=`<span class="unit">ğŸ§¸</span><span class="sub">ğŸ”´</span>`;

      // Last known enemy position (ghost)
      if(revealPos&&revealPos.x===x&&revealPos.y===y&&!isRevealTurn&&state.turn-state.lastRevealTurn<=3){
        if(!content)content=`<span class="unit ghost">ğŸ‘»</span><span class="sub" style="color:#ff444488">ğŸ”´?</span>`;
      }
      // Reveal current position
      if(isRevealTurn&&state.enemy.alive&&state.enemy.x===x&&state.enemy.y===y){
        content=`<span class="unit">âš”ï¸</span><span class="sub">ğŸ”´ì </span>`;
      }

      // Epic monsters
      const epic=state.epics.find(e=>e.alive&&e.x===x&&e.y===y);
      if(epic&&!content){content=`<span class="unit">${epic.epicType==='dragon'?'ğŸ‰':'ğŸ‘¿'}</span><span class="sub">${epic.hp}/${epic.maxHp}</span>`;}
      else if(epic&&content){content+=`<span style="font-size:8px">${epic.epicType==='dragon'?'ğŸ‰':'ğŸ‘¿'}</span>`;}

      // Buff monsters
      const buff=state.buffs.find(b=>b.alive&&b.x===x&&b.y===y);
      if(buff&&!content){content=`<span class="unit">${buff.buffType==='red'?'ğŸ”´':'ğŸ”µ'}</span><span class="sub">${buff.hp}/${buff.maxHp}</span>`;}
      else if(buff&&content){content+=`<span style="font-size:8px">${buff.buffType==='red'?'ğŸ”´':'ğŸ”µ'}</span>`;}

      // Minions
      const minion=state.minions.find(m=>m.alive&&m.x===x&&m.y===y);
      if(minion&&!content){content=`<span class="minion-marker">ğŸŸ¡</span>`;}
      else if(minion&&content){content+=`<span style="font-size:8px">ğŸŸ¡</span>`;}

      const onclick=(moveCells.has(k)||targetCells.has(k))?`onclick="selectCell(${x},${y})"`:'';
      html+=`<td class="${cls}" ${onclick}>${content}</td>`;
    }
    html+='</tr>';
  }
  html+='</table>';
  mapEl.innerHTML=html;
}

function renderStats(){
  const renderPanel=(c,label,id,showFull)=>{
    const hpPct=Math.max(0,(c.hp/c.maxHp)*100);
    const mpPct=Math.max(0,(c.mp/c.maxMp)*100);
    const needed=ANNIE.skills.passive.stacksNeeded;
    let stacks='';for(let i=0;i<needed;i++){const cls=i<c.passiveStacks?(c.passiveStacks>=needed-1?'stack ready':'stack filled'):'stack';stacks+=`<span class="${cls}"></span>`;}
    const xpN=c.level<MAX_LEVEL?XP_PER_LEVEL[c.level]:0;
    const xpP=xpN>0?Math.floor((c.xp/xpN)*100):100;
    const badges=['q','w','e','r'].map(k=>{const s=ANNIE.skills[k];const sl=c.skillLevels[k];const cd=c.cooldowns[k];if(sl<=0)return`<span class="skill-badge on-cd">${s.key}(-)</span>`;if(cd>0)return`<span class="skill-badge on-cd">${s.key}${sl}(${cd})</span>`;if(c.mp<s.manaCost)return`<span class="skill-badge on-cd">${s.key}${sl}</span>`;return`<span class="skill-badge ready">${s.key}${sl}</span>`;}).join('');

    if(showFull){
      document.getElementById(id).innerHTML=`
        <h3>${label} <span style="color:#f0c040;font-size:11px">Lv.${c.level}</span> <span style="color:#f0c040;font-size:10px">ğŸ’°${c.gold}G</span></h3>
        <div class="bar-container bar-hp"><div class="bar-fill" style="width:${hpPct}%"></div><div class="bar-label">â¤ï¸ ${c.hp}/${c.maxHp}${c.shield>0?' ğŸ›¡ï¸'+c.shield:''}</div></div>
        <div class="bar-container bar-mp"><div class="bar-fill" style="width:${mpPct}%"></div><div class="bar-label">ğŸ’§ ${c.mp}/${c.maxMp}</div></div>
        <div class="bar-container" style="height:10px;margin-bottom:4px"><div class="bar-fill" style="width:${xpP}%;background:linear-gradient(90deg,#8844aa,#cc66ff)"></div><div class="bar-label" style="font-size:8px">â­ ${c.level<MAX_LEVEL?c.xp+'/'+xpN:'MAX'}</div></div>
        <div class="passive-bar">ğŸ”¥ ${stacks}${c.redBuff>0?` <span style="color:#ff4444;font-size:10px">ğŸ”´ë ˆë“œ(${c.redBuff})</span>`:''}${c.blueBuff>0?` <span style="color:#4488ff;font-size:10px">ğŸ”µë¸”ë£¨(${c.blueBuff})</span>`:''}${(c.dragonStacks||0)>0?` <span style="color:#ff8800;font-size:10px">ğŸ‰ë“œë˜ê³¤x${c.dragonStacks}</span>`:''}${c.baronBuff>0?` <span style="color:#cc44ff;font-size:10px">ğŸ‘¿ë°”ë¡ (${c.baronBuff})</span>`:''}</div>
        <div class="skill-row">${badges}</div>
        ${c.stunned?'<div style="color:#ff44ff;margin-top:3px;font-size:11px">âš¡ ìŠ¤í„´!</div>':''}
        ${c.items.length>0?`<div class="inventory">ğŸ“¦ ${c.items.map(id=>{const it=ITEMS.find(i=>i.id===id);return it?`<span>${it.icon}${it.name}</span>`:'';}).join('')}</div>`:''}
      `;
    } else {
      // Enemy: show last known info or unknown
      const r=state.lastEnemyReveal;
      if(r){
        const hpP2=Math.max(0,(r.hp/r.maxHp)*100);
        const mpP2=Math.max(0,(r.mp/r.maxMp)*100);
        document.getElementById(id).innerHTML=`
          <h3>${label} <span style="color:#f0c040;font-size:11px">Lv.${r.level}</span></h3>
          <div class="enemy-unknown">ë§ˆì§€ë§‰ ì •ë³´ (í„´ ${state.lastRevealTurn})</div>
          <div class="bar-container bar-hp"><div class="bar-fill" style="width:${hpP2}%"></div><div class="bar-label">â¤ï¸ ${r.hp}/${r.maxHp}</div></div>
          <div class="bar-container bar-mp"><div class="bar-fill" style="width:${mpP2}%"></div><div class="bar-label">ğŸ’§ ${r.mp}/${r.maxMp}</div></div>
        `;
      } else {
        document.getElementById(id).innerHTML=`
          <h3>${label}</h3>
          <div class="enemy-unknown">ğŸ‘ï¸ ì •ë³´ ì—†ìŒ â€” ${REVEAL_INTERVAL}í„´ë§ˆë‹¤ ê³µê°œ</div>
        `;
      }
    }
  };
  renderPanel(state.player,'ğŸ”µ Annie (ë‚˜)','player-stats',true);
  renderPanel(state.enemy,'ğŸ”´ Annie (ì )','enemy-stats',false);

  // Skill level-up
  const p=state.player;
  if(p.skillPoints>0&&p.alive){
    let h=`<div class="skill-lvlup"><span style="font-size:10px;color:#f0c040;margin-right:4px">â¬†ï¸ ìŠ¤í‚¬ í¬ì¸íŠ¸: ${p.skillPoints}</span>`;
    for(const k of['q','w','e','r'])if(canLvlSkill(p,k))h+=`<button onclick="lvlSkill(state.player,'${k}')">${ANNIE.skills[k].key}â†‘</button>`;
    h+='</div>';
    document.getElementById('player-stats').innerHTML+=h;
  }
}

function renderPhase(){
  const el=document.getElementById('phase-bar');
  if(state.gameOver){el.innerHTML='';return;}

  const revealIn=REVEAL_INTERVAL-(state.turn%REVEAL_INTERVAL);
  const revealText=revealIn===REVEAL_INTERVAL?'ğŸ‘ï¸ ì´ë²ˆ í„´ì— ì  ìœ„ì¹˜ ê³µê°œ!':`ğŸ‘ï¸ ì  ìœ„ì¹˜ ê³µê°œê¹Œì§€ ${revealIn}í„´`;

  let html=`<div class="phase-title">í„´ ${state.turn} â€” ${revealText}</div>`;
  html+=`<div class="ai-action">ğŸ”´ AI í–‰ë™: â“ (í™•ì • í›„ ê³µê°œ)</div>`;
  html+=`<div class="player-action">ğŸ”µ ë‚´ í–‰ë™: ${state.playerAction?state.playerAction.desc:'ì„ íƒí•˜ì„¸ìš”'}</div>`;
  el.innerHTML=html;
}

function renderActions(){
  const el=document.getElementById('actions');
  const p=state.player;
  if(state.gameOver||!p.alive){el.innerHTML='';return;}

  if(state.targetMode){
    let label='';
    if(state.targetMode.type==='flash')label='âœ¨ ì ë©¸í•  ìœ„ì¹˜ë¥¼ ì„ íƒí•˜ì„¸ìš”';
    else if(state.targetMode.type==='move')label='ì´ë™í•  ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”';
    else if(state.targetMode.type==='attack')label='ê³µê²©í•  ì¢Œí‘œë¥¼ ì„ íƒí•˜ì„¸ìš”';
    else label=`${ANNIE.skills[state.targetMode.key].key} ëŒ€ìƒ ì¢Œí‘œë¥¼ ì„ íƒí•˜ì„¸ìš”`;
    el.innerHTML=`<span style="color:#f0c040;font-size:12px">${label}</span> <button class="cancel" onclick="cancelTarget()">âŒ ì·¨ì†Œ</button>`;
    return;
  }

  if(p.stunned){
    state.playerAction={type:'wait',desc:'âš¡ ìŠ¤í„´ ìƒíƒœ'};
    el.innerHTML=`<button class="confirm" onclick="confirmActions()">âš¡ ìŠ¤í„´ â€” í™•ì •</button>`;
    return;
  }

  const can=k=>p.skillLevels[k]>0&&p.cooldowns[k]===0&&p.mp>=ANNIE.skills[k].manaCost;
  const flashReady=p.flashCd===0;
  let html=`
    <button class="move" onclick="setPlayerMove()">ğŸš¶ ì´ë™</button>
    <button class="attack" onclick="setPlayerAttack()">âš”ï¸ í‰íƒ€</button>
    <button style="border-color:${flashReady?'#ffff44':'#555'};${flashReady?'color:#ffff44':'opacity:0.35'}" onclick="setPlayerFlash()" ${!flashReady?'disabled':''}>âœ¨ ì ë©¸${p.flashCd>0?' ('+p.flashCd+')':''}</button>
    <button style="border-color:#f0c040" onclick="toggleShop()">ğŸ›’ ìƒì  (ğŸ’°${p.gold}G)</button>
    <button class="skill-q" onclick="setPlayerSkill('q')" ${!can('q')?'disabled':''}>Q ë¶•ê´´</button>
    <button class="skill-w" onclick="setPlayerSkill('w')" ${!can('w')?'disabled':''}>W ì†Œê°</button>
    <button class="skill-e" onclick="setPlayerSkill('e')" ${!can('e')?'disabled':''}>E ë³´í˜¸ë§‰</button>
    <button class="skill-r" onclick="setPlayerSkill('r')" ${!can('r')?'disabled':''}>ğŸ”¥ R í‹°ë²„</button>
  `;
  if(state.playerAction){
    html+=`<button class="confirm" onclick="confirmActions()">âœ… í™•ì •</button>`;
  }
  el.innerHTML=html;
}

function renderLog(){
  const el=document.getElementById('log');
  const recent=state.logs.slice(-60);
  el.innerHTML=recent.map(l=>`<div class="${l.cls}">${l.msg}</div>`).join('');
  el.scrollTop=el.scrollHeight;
}

initGame();
</script>
</body>
</html>
